# 학습
[베르](https://www.youtube.com/watch?v=fRXNV-rfE2o&list=PLYQHfkihy4Azzx1b7CiP3Wb5pc7w5uyxx&ab_channel=%EB%B2%A0%EB%A5%B4%EC%9D%98%EA%B2%8C%EC%9E%84%EA%B0%9C%EB%B0%9C%EC%9C%A0%ED%8A%9C%EB%B8%8C)
[공식](https://docs.unrealengine.com/5.0/ko/setting-up-character-movement/)
[공식 블루프린트](https://docs.unrealengine.com/4.26/ko/ProgrammingAndScripting/Blueprints/QuickStart/)

## 개념
언리얼 엔진의 Visual Scripting System.
블루프린트에서는 보통 프로그래밍에서 사용하는 변수나 함수 등의 요소가 모두 시각적 (비주얼)인 블록(노드) 단위로 구성된다. 이러한 노드를 불러와 연결하면 C++나 C#과 같은 프로그레밍 언어를 사용하지 않고 언리얼 엔진으로 게임을 만들 수 있다.


## 설치
epic games다운받고 
UE5다운받으면
에픽게임즈에 UE5라는 탭 생긴다. 아래에 보면 샘플들 있고 다운로드.
비용 : 기본무료. 백만달러 즉 트리플A급 게임되면 5%의 로열티
용량 : 약 17기가

## 크게 달라진점
1. 퀵셀브릿지
epic에서 인수한 Quixel 직접 스캔한 3d, 2d 제공하는 회사. 이 퀵셀 브릿지가 내장되었다. 에픽게임즈 이용자들에게는 무료로 제공
1. 나나이트 지오메트리
폴리곤 최적화 렌더링을 자동으로
와이어프레임으로 보면 폴리곤으로 볼수있음
폴리곤이 너무 많으면 디테일의 나나이트 세팅의 Enable을 체크하고 적용한뒤 움직이면 렉 안걸림
1. 빛
라이트맵 새로 빌드하지 않아도됨. 다이나믹 글로벌 일루미네이션 시스템인 '루멘' 덕분.


1. 풀바디IK 솔버
지형에 따라 발딛는 위치, 손과 발의 위치 어색하지않음
1. 모션워핑
장애물의 크기를 기준으로 만들어진 애니메이션 자동선택


### 꼭 알아야 할 개념
- 레벨의 디테일 패털에서 저장한건 그 레벨에서만 유효하다. 블루프린트에서 바꿔야 레벨이 바껴도 유지된다.
- 캐릭터 Pawn에 있는 Use Controller Rotation 체크해제

## UI 패널 설명
1. 메뉴바 : 언리얼에 명령과 기능
2. 메인툴바 : 자주사용하는기능들 , 오른쪽끝에 설정(세팅)
3. 뷰포트 : 게임속세상인 레벨을 바라보고 돌아다니고 액터 배치. 모드를통해 세상을 보는 시각을 바꿀수있음
4. 콘텐츠 드로어 : 프로젝트 내에 포함된 에셋 관리
5. 아웃라이너 : 현재레벨에 배치되어있는 모든 콘텐츠를 계층적으로 봄. 원하는 엑터를 빠르게 찾기위해 사용.
6. 디테일 : 엑터의 속성


## 뷰포트
#### 원근뷰
    <마우스로>
    좌클릭한채 드래그 : 카메라 좌우로 회전
    좌클릭한채 위아래 : 카메라 앞뒤로 이동
    우클릭한채 이동 : 고정된 위치에서 회전만
    좌우클릭 동시에 한채로 이동 : 카메라 이동

    <키보드로>
    우클릭누른채로 WASD와
    그냥 WASD
    QE : 위 아래
    CZ : 줌인 줌아웃

    <빠른이동>
    맵이 너무 클경우 액터를 아웃라이너 패널에서 선택후 더블클릭 또는 F키(포커싱)

    <기타>
    ALT + 좌클릭드래그 : 포커싱한 액터를 중심으로 회전
    ALT + 우클릭드래그 : 포커싱한 액터를 중심으로 뷰포트 카메라 앞뒤이동

#### 직교뷰
    와이어프레임 설계도같이 볼수있다.
    거리의 왜곡없이 실제 길이에 맞게 보인다.
    우클릭 드래그 : 카메라 이동
    좌클릭 + 우클릭 드래그 : 줌인/줌아웃
    휠 드래그 : 길이(거리) 측정

## 엑터  ## Actor
- 개념 : 게임에 배치할 수 있는 모든 오브젝트
- 주요기능 : 시각적 기능(보여주기), 물리적 기능(이동, 상호작용), 움직임
- 선택 : 클릭
- CTRL 선택 : 다중선택, 이미선택된것에서 제외
- 트랜스폼 조작 : 기즈모의 모양을 보고 알수있다. 
  - 화살표는 그축으로, 면으로 당기면 그 평면으로
  - 스냅단위를 바꿔주면 단위크기가 바뀐다. 기본은 10
  - 이동 W
  - 회전 E
  - 크기조절 R
- **엑터선택후 ctrl b** : 해당엑터의 블루프린트
- **블루프린트에서 드래그후 c** : 영역감싸고 커맨트 넣을수있음
- 엑터배치할때 키보드 end키 누르면 물리적충돌지점에 딱 붙음

### 표시조작
- 뷰포트에 보이는 아이콘들은 월드에 배치되었지만 게임중인 플레이어의 눈에는 보이지 않는 환경적인 요소(원, 빛, 소리 등)
- 게임모드 : G



- 실시간 재생 : CTRL R
- 몰입모드 : F11

### 공부
영어 검색이 훨씬 자료가 많고 공식 문서도 영어.
엔진이나 툴 설정을 영어로 하는것을 추천
메뉴바 - 편집 - 에디터 개인 설정 - 지역&언어 - 영어로 변경

## Actor
  > 레벨에 배치할 수 있는 오브젝트
  > 이동, 회전, 스케일과 같은 3D 트랜스폼을 제공하는 범용 클래스
  #### Mesh Actor
  환경소품 또는 플레이어 캐릭터의 모양과 크기를 정의한다. 
  언리얼은 2가지 유형의 매시 엑터가 있다.

    ##### Static Mesh Actor
    - 레벨 및 환경을 빌드하는데 사용
    - 비디오 메모리에 캐시되고 그래픽 카드에서 렌더링 할 수 있는 폴리곤 세트로 구성되는 지오메트리 조각
      지오메트리에 쓰이는 기본단위.
    - Static이 붙었지만 액터가 고정상태임을 말하는것이 아니라 메시유형이 스태틱. 즉 지오메트리가 변화하지 않는다는 말이다.
    그말이 또 엑터 자체가 변할수 없다는 말은 아니다.
    - 유형 : 큐브, 구체, 원기둥, 원뿔, 평면

    ##### Skeletal Mesh Actor
    - 플레이어 캐릭터와 애니메이팅된 NPC에 사용
    - 지오메트리를 변혈할 수 있는 에니메이팅된 메시

  ### Brush Actor(지오메트릭 엑터)
  - 씬에서 구체, 큐브, 계단 등 단순한 3D 지오메트리를 나타내는 기본 엑터 유형.
  - 유형 : 박스, 원뿔, 원기둥, 굽은계단, 선형계단, 나선계단, 구체
  ### Light Actor
  - 레벨에 다양한 유형의 빛을 배치하는데 사용된다.
  - 유형 
    - 디렉셔널 : 무한히먼광원
    - 포인트 : 사방으로 퍼지는전구
    - 스포트 : 스포트라이트
    - 렉트 : 사각형평면
    - 스카이 : 하늘의 모습과 라이팅이 일치
    
  ### Camera Actor
  - 레벨을 보고 시네마틱 시퀀스를 생성하는데 사용
  - 유형
    - 카메라엑터
      스테이셔너리 또는 모바일 뷰포인트로 사용할 수 있는 일반적인 카메라
    - 시네카메라엑터
      시네마틱 제작에 사용되는 특수한 카메라
  - 위의 카메라 엑터 외에도 카메라블로킹 볼륨, 카메라릭크레인, 카메라릭레일, 레벨시퀀스액터를 통해서도 카메라 작업을 할 수 있다.
  ### 오디오 및 사운드 액터
  ### 게임플레이 액터
  - 인터랙티브 기능을 트리거한다.  사실 이름과 달리 게임뿐만 아니라 모든 종류의 인터랙티브 어플에서 활용된다.
  - 플레이어 스타트 : 레벨에 배치되어 플레이어가 레벨을 시작할때 플레이어 캐릭터를 스폰할 위치를 지정
  - 트리거 볼륨 : 레벨에서 엑터가 다른것과 인터렉션할때 이벤트를 일으키는 액터
  - 블로킹 볼륨 : 플레이어가 지나가지 못하게 막는데 사용
  - 킬Z 볼륨 : 플레이어캐릭터가 이 지역에 들어오거나 인터랙션 하는즉시 캐릭터를 죽임
  - 페인코징 볼륨 : 이 안으로 들어온 오브젝트에 도트데미지를 가함
  ### 폰 ### PAWN
  - 월드 내 플레이어 또는 AI 엔티티의 물리적 표현
  - 플레이어의 입력에 반응하게 하려면 컨트롤러 컴포넌트를 Attatch해야한다는점을 기억해야한다.

  ### 캐릭터 ### Character
  - 월드에서 걷고 달리고 점프하고 비행하고 헤엄칠 수 있는 수직 체형의 플레이어 캐릭터용으로 특정하게 설계된 폰 유형
  - 유형
    - 캐릭터
      캡슐콜리전, 빈메시, 캐릭터무브번트.    그대로 사용하면 레벨에 보이지는 않지만 조종가능
    - 건축시각화캐릭터 : 1인칭 클래스를 기반으로 함. ??
    - 페이퍼캐릭터 :  2D프로젝트에 사용. 페이퍼플립북컴포넌트(스프라이트)를 사용.

---
# 용어정리
- Controller 클래스
Pawn또는 캐릭터처럼 폰에서 파생된 클래스를 빙의(possess)하여 그 동작을 제어할 수 있는 눈에 보이지 않는 엑터.
- 컴포넌트
액터에 특수한 기능을 추가할 수 있는 오브젝트
- 그레이박스
맵을 처음 만들 때는 텍스처를 사용하지 않고, 동그라미나 네모와 같은 기본적인 형태와 테스트 애셋으로만 만드는 경우가 있는데, 이렇게 만든 맵을 그레이박스라고 한다.
- 그레이박싱
게임의 외형을 버리고, 게임의 본질에 주목해서 빠른 속도로 맵을 만들어보는 공정을 그레이박싱이라고 한다.
- BSP
아래의 그림과 같이 모드 패널의 BSP 카테고리에 있는 다양한 도형들을 사용해서 맵을 모델링 하는 기능
- 메싱
각 폴더에 임포트했던 완성에 가까운 정식 애셋을 이용하여 만들었던 그레이박스를 교체하는 과정
- 스켈레탈 매시
관절을 사용하는 메시
- 페르소나
애니메이션과 관련된 작업을 수행할 수 있는 에디터
- 라이트맵이
맵상에 있는 액터의 위치나 크기를 파악하기 위한 눈에 보이지 않는 막.
빛은 이 라이트맵의 정보에 따라 어디에 어떤 액터가 배치되어 있는지 알 수 있다. 그리고 빛이 액터를 비추며 상태에 따라 그림자가 만들어 진다.


### 노하우
1. 캐릭터가 이동방향을 바라보면서 움직이게 하려면
 : Pawn에 해당하는 컴포넌트를 선택하여 디테일 패널의 Pawn 카테고리에 있는
Use Controller Rocation Yaw의 체크를 해제한다. 
 (조작이 어떻게 되든 캐릭터가 이동하는 방향)
 만약, 체크되어 있을 경우에는 Pawn의 방향이 Controller의 방향과 함께 움직이게 된다.
 (캐릭터의 이동방향이 아니라 조작컨트롤러의 방향)

 캐릭터의 이동 처리를 담당하는 컴포넌트를 선택하여 디테일 패널의 Character Movement 카테고리에 있는 Orient Rotation to Movement에 체크한다. 이 기능은 캐릭터의 이동 방향으로 향하게 회전시켜주는 기능을 한다.

---
### 큐브그리드와 프로토타입
창 - 환경라이트믹서 - 버튼들을 순서대로 눌러주면 기본세팅
//단, Create Atmosphere Light ( 대기빛생성)은 0번만 선택하고 1번 안함. 아주 특별한 경우만 대기빛 여러개
그러면 비어있는 레벨이 자연스러운 하늘로 바뀜
ctrl + L 누르고 마우스를 움직이면 아주 빠르고 쉽게 레벨의 메인 빛의 방향을 변경할 수 있다.

큐브나 실린더같은 액터 배치보다 훨씬 좋은방법이 큐브그리드 기능
메인툴바 - 모드를 모델링 모드로 변경 - 모드패널의 PolyModel섹션에서 CubeGr 선택 - 레벨에 그래드가 보임
원하는 영역을 선택하고
E 누르면 선택한 영역에 큐브가 한칸 쌓임.
Q 누르면 선택한 영역이 깎임.
CTRL 드래그로 빠르게 쌓거나 깎을 수 있음

CTRL + E : 그리드 한칸을 크게 만듦
CTRL + Q : 그리드 한칸을 작게 만듦

CubeGr의 Corner Mode선택 - 요소의 모서리 선택 - 큐브를 올리거나 내리면 경사로가 만들어짐

원하는 큐브그리드를 만들었으면 가운데 있는 Complete버튼 클릭하면 형태가 확정되면서 빛의 영향을 받게됨

<형태완성후>
콘텐츠브라우저 우클릭 - 퀵셀콘텐츠추가(Add Quixel Content) - 브릿지패널 열고 - 여러가지 텍스처와 모델 가져옴 - 레벨 꾸미기

<엑터 배치>
레벨에 플레이어 스타트 액터 배치

--- 
프로그래밍
[C++클래스 생성과 기본 이벤트](https://www.youtube.com/watch?v=DkJqLIpSvik&list=PLYQHfkihy4Azzx1b7CiP3Wb5pc7w5uyxx&index=8)
프로젝트 타입 C++선택해야함.
뭔가 에러가 뜬다면 밑에 링크있는것들 들어가서 설치하면된다.
- 클래스 생성방법
  1. 메뉴바 - 툴 - 새로운c++클래스 생성
  2. 콘텐츠브라우저 - C++클래스폴더 - 추가버튼
  부모클래스 선택. Actor(레벨에 배치할수있는 오브젝트)선택해보자.
  cmd창 뜨고 초록색으로 Successfully linked patch   하고 ---- Finished ---- 뜬다.
  컨텐츠 브라우저의 소스패털 열고 - C++Classes폴더 보면 헤더파일과 소스파일 2개가 생긴걸 볼수있다.
  헤더파일 열면 소스파일을 열면 3개가 이미 생성되어있다.
      - 생성자 : 기본값 세팅
      - BeginPlay함수 : 리스퐅될때 한번 호출
      - Tick함수 : 프레임마다 호출
- 로그 남기기
    UE_LOG(카테고리명, 포맷, 값)
    예) UE_LOG(LogTemp, Log, TEXT("Constructor"));
- UE5에서는 컴파일 버튼이 사라졌다. 대신 라이브코딩
콘솔명령어에서 LiveCoding.Compile 명령어 또는 **Ctrl + Alt + F11**
- 로그보기
하당툴바의 출력로그 버튼 - 로그패널 레이아웃에 고정 - 위에서 만든 MyActor를 씬에 배치하고 플레이 

[변수, UPROPERTY](https://www.youtube.com/watch?v=VyYqyVe3vQI&list=PLYQHfkihy4Azzx1b7CiP3Wb5pc7w5uyxx&index=9)
- 변수타입 : 정수, 소수, 문자열, 논리변수
    정수 : int8, int16, int32, int64, uint8, uint16, uint32, uint64, 
    소수 : float, double
    문자열 : std::string,
            FString = TEXT()매크로 사용해야함
            TCHAR
    논리 : bool
- 변수선언 : 클래스의 헤더파일의 public: 안에 선언
- 접근제한자 : public, protected, private
- UPROPERTY : 언리얼 엔진 에디터에서도 보이고 사용할 수 있도록 하기 위한 매크로. 변수마다 붙여줘야한다.
    매개변수에 EditAnywhere, BlueprintReadWrite, Category="Damage"
  - EditAnywhere : 아키타입(archytype) 과 레벨에 배치된 인스턴스 양쪽 모두의 프로퍼티 창에서 편집할 수 있음
    - archytype : 아직 인스턴스화 되지 않은 블루프린트 원본
  - BlueprintReadWrite : 블루프린트에서 읽기와 쓰기 모두 가능
  - Category="Damage" : 블루프린트나 언리얼에의 이 변수 표시를 저이름의 카테고리로 묶어서 보여줌
  - VisibleAnywhere : 보이지만 편집 안됨
  - Transient : 휘발성으로 저장되지 않음
  

- 컴파일 후 레벨에 배치
- 선택후 디테일패널에서 프로퍼티들 보이는거 확인

- 프로퍼티의 기본값 설정. 생성자 함수에서. 
  - 1번방법  :  .cpp파일의 생성자 옆에 콜론입력후 프로피터이름(값), 프로퍼티이름(값)
  - 2번방법 : 생서자의 바디에서 기본값 대입
  신기하게 커멜케이스로 변환되어 띄워쓰기 해줘서 보여주네
  다시 컴파일하면 초기화값으로 온걸 확인할수있다는데 안바뀜

---
### paraer 2d 
페이지 하나씩 넘기면서 조금씩 달라지는 그림이 움직이는것처럼 보이게 하는 현태의 수동 애니메이션
그렇게 만들어진 움직임 하나를 Flipbook이라 한다.
키프레임으로 구성되며.   키프레임은 스프라이트와 이를 표시할 기간이 포함된다.


---
[언리얼5 공식문서](https://docs.unrealengine.com/5.0/ko/)
[2d 애니메이션과 움직인 구현](https://www.youtube.com/watch?v=r41W7O22zgo&list=RDCMUCwdKySs6j48yl1ae8csAurQ&start_radio=1&rv=r41W7O22zgo&t=585&ab_channel=Chris%27Tutorials)
[아이언맨](https://www.youtube.com/watch?v=ZTsDv2jdTsg&t=223s&ab_channel=Uisco)


### [udamy 2만5천원짜리](https://www.udemy.com/course/learn-how-to-make-a-2d-platformer-in-unreal-engine/learn/lecture/30917874#learning-tools)
강의자 : Uisco. 유튜브에도 강의몇개있음
- 한글 영어로 바꾸기
Edit - Editor Preference - 지역 & 언어

> 1강. 프로젝트 생성
블루프린트로 시작용컨텐츠없이 platformer2dproject
창 - layout - classic ue4로 변경



> 2강. 자료 다운로드 
리소스 다운로드

> 3강. 키세팅 Settins Up Input Player Input
Content에 폴더 생성 (이름 : 2DPlatformerBlueprints)
  콘텐츠뷰에서 그폴더 들어가서 - 우클릭 블루프린트 클래스 - 부모에 paper검색해서 paper character선택 - 이름은 2dCharacter  //pawn모양 아이콘으로 파일 생김

상단 Edit창 - project edit - 엔진 - 입력 - Bindings -
  Actions Mappings에   Jump 라는 이름으로 키보드 SpaceBar, Up
  Axis Mappings에 Moveright라는 이름으로 Right   1.0 , Left -1.0 

3. 리소스 가져오기
Sprites폴더 생성 안에 PlayerCharacterSprites폴더생성
다운받아놨던 2D Platformer Course Assets 폴더의 HeroSprites 내부폴더 전부다 복붙

4. paper2d로 변경
idle폴더 들어가서 전체선택하고 우클릭 스프라이트액션 - 페이퍼2d텍스쳐적용    이렇게 하니 확대해도 안깨지네. 배경투명하게되고
5. Sprite 생성
idle폴더 들어가서 전체선택하고 우클릭 스프라이트액션 - 스프라이트생성
6. 플립북 생성
생성된 스프라이트 선택후 우클릭 - 플립북 생성.    만들어진 플립북의 애니메이션 확인. 속도 5로 변경
idle 끝났다.  run, jump, Fall에 대해서 4번부터 반복
점프와 런 속도는 15, 


---
> 4강. 블루프린트 Setting Up The Player Character Pt1
아까만든 2dCharacter 블루프린트 더블클릭. 풀블루프린트로 열기
- 뷰포트에 캡슐 컴포넌트 확인.
  그 하위의 Sprite 선택하고 오른쪽 Source Flipbook을 idle에니메이션으로 바꿔주기
    location 20, 0, 20
    Scale 5, 5, 5
    로 변경하면 적당하게 찬다.
  다시 Capsule가서 오른쪽 Shape에서 캡슐의 모양을 바꿔줄수있다. 83, 36으로 변경
- 이벤트 그래프
  - 우클릭  - jump검색 - 인풋의 액션이벤트로 있는 jump 선택 - Pressed를 캐릭터의 jump와 연결
                                                         - Relased를 캐릭터의 Stop Jumping과 연결
  - 우클릭 - move right 검색 - Axix Events에 있는거 선택  - Add Movement Input과 연결
    //**Add Movement Input노드**는 Pawn을 받은 방향으로 값만큼 이동시키는 노드다.
    Axis Value값(초록)은 Scale Value값(초록)과 연결
    월드에서 변경해야될 World Direction X 1로 변경
  - 왼쪽이동은 강의에 없는데 똑같이 해주면됨
- 카메라 고정
  - 다시 뷰포트로 가서 캡슐컴포넌트에 camera카테고리에 있는 SpringArm추가. rotate변경해서 정면을 바라보도록
  - SpringArm하위에 Camera추가 - 방향 캐릭터를 보도록 변경,
                  - 오른쪽 Camera Settings - Projection Mode(투명모드)를 Orthographic으로. 
                                            Ortho Width 1000으로 변경
    컴파일

- 벽 생성
콘텐츠 브라우저로 가서 Content/Sprites하위에 Objects폴더 생성 - GreySquare 폴더 생성
다운받은 폴더의 Objects폴더의 greysquare 가져오기 - 우클릭 create sprite
- 2dCharacter 레벨에 배치
(**중요**)카메라가 캐릭터에 고정안돼있음.  무빙치면 카메라가 무빙됨.
  : 캐릭터 선택후 디테일에서 pawn검색. Auto Possess Player(플레이어 자동방의) Disabled 돼있떤거 Player 0으로 변경
  //Player0은 온라인이 아닌 로컬플레이어를 의미하는데 Player0폰으로 빙의되므로서 자동으로 Player0폰을 컨트롤하는 입력이 활성화된다.
- greysquare스프라이트 화면에 배치
캐릭터의 y축 0으로 바꾸고 바닥에 배치하고 길게 늘린다음 게임 플레이
---
위까지 이제 idel형태로 점프, 좌우무브, 땅에 딛기 까지 됨
- 왼쪽버튼을 눌렀을때 강의는 오른쪽을 보면서 왼쪽으로 움직이는데  나는 왼쪽을 보면서 오른쪽으로 움직인다.
  카메라 액터 클릭하고 Pawn에서 Use Controller Rotaion Yaw 체크해제하면 오른쪽만 보면서 왼쪽 이동됨
  z축으로 180주면 왼쪽으로 보는건 블루프린트에서 확인함
- 카메라가 깜빡거리는 문제가 있음
-> 카메라 깜빡이는건 하늘 지우니까 사라짐.
- 4까지는 똑같이 따라함
-> 하...씨 블루프린트 지웠다가 다시 배치시키니까 되네.. 3일 날렸다.
---
> 5강. Settings Up The Player Character Pt2
- 캐릭터 회전
[플레이어 이동, 회전 블로그](https://ansohxxn.github.io/ue4%20lesson%201/ch3-2/)
캐릭터 SpringArm - 디테일의 트랜스폼 - 회전 클릭해서 상대회전을 월드(절대) 회전으로 변경
Envet Graph의 Event Tick에 연결할거다. 
먼저 왼쪽컴포넌트에있는 캐릭터무브번트 가져오기 - get velocity검색해서 연결(Velocity카테고리) - 우클릭 구조체 핀 분할 하면 x,y,z축 속도 나온다.
Event Tick 화살표 끌어서 Print String 연결한다음 Velocity X랑 연결시켜서 화면에서 찍어보기.  +600, -600 나온다.
   확인했으면 지우고 Velocity X를 Compare Float와 연결.  Input은 속도 x와 연결
3분까지 따라했는데 잘안됨!!!!!




**회전**
- Use Pawn Control Rotation : 컨트롤러의 회전값을 사용.  
  - Pitch : 횡축을 중심으로 회전. 비행기로치면 상승하강
  - Yaw : 수직축을 중심으로 회전. 잔나 공중에뜸. 비행기로 치면 바라보는방향이 바뀜.
  - Roll : 종축을 중심으로 회전. 머리와 꼬리 선을 중심으로 회전. 레넥톤. 비행기로 치면 회전회오리


//체크해제하면 캐릭터의 방향과 이동방향을 독립적으로 제어됨.  
4분까지 print로 찍기
  branch빼고
  greater빼고
  Ismovingright?변수 생성.  드래그앤드랍. set으로 설


플립북의 축이 이상한거 발견
스프라이트 만들때 오른쪽탭에서 Source Dimension 건드려줌


> 6강. Giving The Player Character Animations
1. 블루프린트에서 영역지정하고 c로 커맨트 달아줌
1. UpdateAnimation껍데기 정의
   우클릭 - Add Custom Event. 이름은 UpdateAnimation
2. UpdateAnimation호출
   EventTick에 드래그해서 UpdateAnimation연결
3. 정의 내용 채우기
  Get Velocity - Vector Length - greader - Select 연결
  Sprite 드래그앤드랍 - Set Flipbook 연결
      Select의 False - Set Flipbook의 New Flipbook 연결. 어셋은 idle 플립북
      Select의 True 우클릭 run이라는 이름으로 컴포넌트 만들기. 어셋은 run 플립북
  Updateanimation을 Set Flipbook시작과 연결
4. Select의 True우클릭 Promote to Variable 선택. 이름 run으로 변경
            False마찬가지. 이름 idle로 변경
            만든 idle과 run 카테고리 Animation으로 지정
5. 실행해보면 달리는거 된다. 이제 점프하자.
6. 점프 블루프린트구현
   빨간색 UpdateAnimation 우클릭 Branch 만들어서 연결
   왼쪽에서 Character Movement드래그앤드랍 - 끌어서 is falling 연결 - Branch의 Condition에연결 - False는  Set Flipbook에연결
   오른쪽위 Select영역 복사해서 붙여넣기
   그 앞에 GetVelocity 한다음 Split Struct Pin - Z축끌고 Less함수 연결 - Select의 Index와 연결
   True일때 애니메이션 Fall로 변경, False일때 Jump로 변경
   Branch의 True는 Set Flipbook과 연결
   또 True일때 변수등록 Falling으로 이름변경
     False일때 변수등록 Jumping으로 이름변경
     카테고리는 Animation
7. 실행해보면 강의는 정상인데 나는 정점에서 잠시 투명으로 변함. 뭐지 다시하니까됨

> 7강. Changing The Player Characters Speed  뛰기 최대속도 조정
1. 어제했던거 묶어서 c(Comment)  Handle Animation
2. 왼쪽 Character Movement클릭해서 오른쪽 Details에서 speed검색   걷기 최대속도, 수영최대속도 등 조절할 수 있다.
3. Character Movement 드래그앤드랍해서 오른쪽 뽑아내서 Set Max Walk Speed 만들고
4. Event BeginPlay(빨간색)을 Set 의 시작과 연결
5. Max Walk Speed 우클릭해서 변수로 뽑고 이름 Playerspeed
6. DefaultValue는 600으로
7. 컴파일

> 8강. Adding Sprinting 빨리뛰기 구현
1. Edit - Project Settings - Engine - Input - Action Mappings에 Sprint추가 left shift 지정
2. 블루프린트의 animation영역 열어서 범위 늘리고 우클릭 - sprint검색(1번을 해야 나온다.)해서 InputAction Sprint(빨간색)
3. Character Movement 드래그앤드랍 - 오른쪽 연결 - set max walk speed - 변수로 뽑고 SprintingSpeed로 이름짓고
4. InputAction Sprint(빨간색)은 SET의 시작으로 연결. 
5. 디폴트 속도는 850(컴파일 해야 편집가능하게 된다.) -> 개인적으로 느려서 1000으로 바꿈
//이제 눈에 좀 보이네. Character Movement라는 객체가 있고 그놈의 속성에는 Max Walk Speed가 있으나 Set함수가 있고 그놈을 호출한거. 언제? Input Sprint가 Pressed됐을때
6. 빨간색빼고 방금만든 3개 복붙
7. InputAction Sprint(빨간색)의 Released를 새로만든 Set과 연결
8. 아래의 Sprinting Speed를 PlayerSpeed로 변경>

> 9강. Creating Dash Ability
1. Content폴더에 Levels폴더 만들고 현재 레벨과 레벨데이터를 그 안으로 넣기
2. 캐릭터 블루프린트 들어가서 왼쪽 Camera 컴포넌트 선택하고 Ortho Width 를 1000에서 2000으로 변경
3. 맵에 만들었던 땅들 복붙해서 여러가지 벽 세우고 하기.

애니메이션
4. Content - Sprites - PlayerCharacterSprites - Dash
들어가서 2d로 만들고 sprites로 만들고 flipbook으로 만들기
5. 프로젝트 세팅 - 엔진 - 인풋 들어가서 Dash라는 이름으로 Z키 매핑


이벤트핸들링
6. 캐릭터 블루프린트 들어가서 handle input event영역 늘리고 우클릭 dash
7. 변수에 있는 IsmovingRight? get으로 가져오고(빨강) Select와연결(초록)
8. handle input event 의 Pressed를 Launch Character(파랑)만들어서 연결. 
  Launch Velocity는 split으로 쪼개기
9. Select의 False를 Launch Character(파랑)의 Launch Velocity X와 연결하면 값넣을수있고 -2500으로 바꾸기. True는 2500으로. 
10. Launch Character(파랑)의 XYOverride 체크
11. 플레이 테스트   //매우 멀리 빠르게 이동함.
12. 캐릭터 블루프린트 왼쪽 컴퍼넌트에서 Character Movement  - Jumping/Falling의 Falling Lateral Friction 0되어있는걸 2로 변경
13. 이제 대쉬처럼 이동함
14. 캐릭터 블루프린트  - 변수 - Animation에 있는 Jumping 복사해서 Dash로 만들기
    컴파일하고 오른쪽  Details에서 Flipbook 대쉬로 바꿔주기
15. isDashing?  변수 추가
16. 드래그앤 드랍으로 블루프린트에 SET으로 넣고 Launch Character(파랑)의 오른쪽을 이놈이랑 연결. 
    isDashing? 체크
17. 드래그앤 드랍으로 Dash   추가. Dash의 오른쪽 get Total Duration 만들면서 연결
    이놈의 오른쪽은 Retriggerable Delay만들면서 연결
18. isDashing을 드래그앤드랍으로  Set으로 가져오고 Retriggerable Delay의 오른쪽과 연결
/* 분석공부
//Launch Character 함수는 캐릭터의 현재속도에 더할속도를 더해서 원하는 방향으로 대상을 날릴 수 있게 해준다.
// Dash에 해당하는 키를 눌렀을때(InputAction Dash - Pressed) LaunchCharacter 함수 호출.
// 이 함수가 호출될때 x축속도를 인자로 전달받는데 
//오른쪽으로 움직이고 있는 상태면 x축으로 3300만큼 속도 증가.     오른쪽으로 움직이는 상태가 아니면 x축으로 3300만큼 속도 감소.
//함수끝나면 isDashing?변수 true로 변환.
//다시트리거 가능한 딜레이. 즉 잠시멈췄다가 isDashing?변수 false로 변환.
//얼마나 멈출까? 대쉬라니는 페이퍼클립의 총기간동안.
*/

핸들에니메이션
1. Updateanimation왼쪽으로 더 끌고 원래있던 Branch사이에 새로운  Branch만들고 새Branch의 False를 기존 Bransh와 연결
2. isDashing?을 GET으로 넣고 새 Branch의 Condition에 연결
3. 캐릭터 스프라이트(파랑)를 드래그앤드랍 넣고 SetFlipbook(파랑) 생성하며 연결. 
4. Dash 페이퍼플립 드래그앤드랍하고  New Flipbook에 연결
5. 아까만들었던 새Branch 의 True는 이 SetFlipbook(파랑)과 연결
6. 테스트완료.
/* 분석 공부
//에니메이션업데이트는 분기처리된다. IsDashing?변수값의 상태에 따라서.
//True면 유저의 Sprite를 타겟으로 새로운 플립북을 호출한다. Dash라는.
*/

수정
1. Select의 속도 +-3300으로 바꿈
2. Character Movement의 Falling Lateral Friction 2.5로 바꿈

> 10강. Creating Wall Slide Mechanic 벽에 미끄러지기
플립북만들기
1. WallSlide 폴더의 이미지들 paper로 만들고 Sprete로 만들고 플립북까지 만들기

캐릭터 블루프린트
1. 껍데기정의 : 빈공간에 우클릭 Custom Event.  이름 : WallSlidemechanic
2. 호출 : Character Direction(캐릭터가 쳐다보는방향)영역의 EventTick의 UpdateAnimation 오른쪽에  방금만든 WallSlidemechanic 연결
3. 본문 채우기 : WallSidemechanic부분으로 가서   Character Movement 드래그앤드랍 - is Falling - branch
4. WallSlidemechanic끝과 Branch시작 연결.  true면 LineTraceByChannel(선따라 움직이는 함수) 호출
5. Start는 getActorLocation(시작지점은 액터의위치)
6. GetActorForwardVector 생성 - Multiply - Split(쪼개기) - x를 50
7. GetActorLocation의 ReturnValue에 Add함수 연결.   add함수의 시작을 방금만든 x와 연결. 그리고 그 add함수의 결과를 End로 연결
8. LineTraceByChannel의 Draw Debug Type은 For Duration으로 변경
9. Start의 Out Hit은 Break Hit Result
10. Blocking Hit을 변수로 등록. 이름은 Wallslide?
11. 자동으로 만들어진 Wallslide? Set의 시작을 LineTraceByChannel의 끝과 연결

12. 아까만들었던 isFalling Branch의 False는 WallSlide?함수 끌고온다음 연결

로그 찍어보기
1. 제일오른쪽 Wallslide? Set 함수에서 printString 해보고 실행하면 벽에 부딪혔을때 true, 아닐때 false찍힌다.
2. 확인됐으면 다시 로그 제거

에니메이션 변경
1. handleAnimation영역의 UpdateAnimation(빨간색)과 연결되어있는 Character Movement의 IsFalling Branch True에 Branch생성후 연결
2. True의 링크 우클릭으로 끊고
3. Wallside?변수 get으로 가져와서 Condition에 연결
4. false면 그냥 Sprite의 SetFlipbook(원래꺼)에 연결
   true면 새롭게 Sprite의 SetFlipbook생성해서 벽타는거 할건데 아직 블루프린트에 등록이 안됐다. 만들어줘야지
5. Animation의 Dash 복제해서 wallslide로 이름변경
6. 컴파일후 Default Value 플립북 이미지 벽타기로 바꿔줌
7. get으로 가져와서 New Flipbook과 연결
8. Branch의 True를 이 SetFlipbook과 연결
9. 컴파일

바라보는 방향 변경 
1. Character Direction(캐릭터가 쳐다보는방향)영역의 EventTick -  UpdateAnimation - WallSlidemechani에 branch연결
2. true 끊기
3. Wallslide?변수 get으로 가져와서 Condition에 연결
4. false는 CompareFloat에 연결
5. True는 아직 미연결
6. 컴파일후 테스트   //아직 벽에 완전히 안붙는 문제가 있음. 강의에서도.


> 11. Creating Wall Jump
1. 핸들이벤트 점프 수정
  그냥 벽말고 점프중에 벽에 부딪혔을때 가능해야하니까
  InputAction Jump - Pressed 에 Branch연결. True링크 끊고
2. Wallslide? Get으로 가져와서 Condition에 연결
3. False면 Jump와 연결
4. True면 LaunchCharacter
5. 속도 split
6. 우클릭 GetActorForwardVector함수호출. reuturn split하고 x를 multiply함수호출. -1500후 Lunch Velocity X와 연결
7. Launch Velocity Z는 650으로 값입력, XY, Z Override 둘다 체크
//Override 체크안하면 정점에 도달전에 벽에 부딪히면 다시 위로 파워풀하게 점프 하는듯.
//                   정점에 도달후에 벽에 부딪히면 무조건 아래로만 점프 하는듯

공중에서도 명령 먹도록 구현구현
1. Character Movement Details에서 air검색
Air Control에 대한 설명보면 떨어질때, 이 숫자는 캐릭터를 움직이게 하는 리터럴이다. 0은 움직일수 없음. 1은 완전히 컨트롤
0.05였는데 1.0으로 변경

2. 실행해보면 아직 2가지 문제가있음
   1. 벽에 찰싹 달라붙어있지 않은것
   2. 맨마지막에 뚫려있는벽에서 높이 뛰는것
3. 2.1부터 해결하자. 

캡슐 콜리젼 3:10
1. 캐릭터 블루프린트의 Capsule Component - Details에 hidden검색
   체크해제하면 게임에서 캡슐형태가 보임. 오~~ **중요**
1. Handle Animation. UpdateAnimation쪽에  Capsule Component 드래그앤드랍. 
2. Set Capsule Radius호출. Radius를 1로 변경
3. 원래 Branch True랑 연결된거사이에 이놈을 추가
4. Capsule Component로 돌아와서 SHAPE의 Capsule Radius 확인. 32
5. Capsule Component와 Set Capsule Radius복붙. 32로변경
6. Branch의 False랑 연결된거 사이에 이놈 추가. 

벽슬라이딩때도 캡슐 수정해줘야지
Get Actor Forward Vector - X: 50이던거 5로 변경
//으... 나는 오른쪽 벽에 슬라이딩할때 완전히 벽으로 숨어버린다...
=> 해결 블루프린트의 캐릭터 스프라이트에 Y축이 0이 아니였음.
1. Draw Debug Type - none으로 바꿔서 형관색 표기안나게하고
2. 캡슐 표시나던것도 hidden 찾아서 제거

--- 챕터2 . 적 캐릭터 설정---
> 12. How we are hoing to set up are enemy characters
1. 콘텐츠창 Sprites 폴더에 Enemies 폴더 생성
2. 다운로드한 에셋의 Enemies에 있는 3개폴더 복붙
3. Enemies폴더에서 우클릭 Create Adanaced Asset영역에 있는 Blueprints - Enumeration.  이름은 Listofenemies
4. 3개 변수 추가하고 MushroomEnemy, GoblinEnemy, FlyingEnemy 라고 이름 바꾸고 Save

> 13. Setting Up Strucrues
강의랑 화면이 좀 다르다. Default Value창을 밑으로 하면 같아짐
1. Enemies폴더에서 우클릭 Create Adanaced Asset영역에 있는 Blueprints - Structure.  이름은 EnemyStructure
2. type은 listof검색해서 listofnemies 선택. 이름은 EnemyType
3. 적의 종류가 7개일거기 때문에 7개 더만들어줌. 이놈들의 타입은 paper flipbook object
4. 이름은 Idle, Moving, Attacking, Ranged Attack, Damaged, Die, Dead Body

> 14. Setting Up The Data Table
1. Enemies폴더에서 우클릭 Create Adanaced Asset영역에 있는 Miscellaneous - Data Table
   - RowType으로 EnemyStructure선택
   - 이름은 EnemyDataTable
2. 더블클릭으로 열어보면 EnemyStructure에서 등록했던 변수들이 테이블형태로 보인다. 
   머쉬룸부터 등록해보자. 먼저 머쉬룸 리소스를 만들어야한다.
3. Mushroom 폴더로 이동
   3.1 Idle, Attack, RangedAttack, Projectile, Run, Damaged, Death 폴더만들고 각각 이미지 폴더안으로 넣기
   3.2 Attack폴더로 들어가자. 이미지 하나에 여러그림들이 그러져있으니 분리해야한다. 우클릭 - Sprite Actions - Apply Paper2D Texture Settings
   3.3 우클릭 Sprite Extract. Grid선택, Width는 150, Height는 그대로 150
   3.4 전체선택후 Create Flipbook.  이름은 MushroomAttack
   3.5 폴더돌아가면서 똑같이
   3.6 Death는 맨마지막 죽은 이미지는 별도로 하나더 Flipbook생성. 죽어있는채로 표현할거기때문. mushroomDeadBody
4. 이제 테이블들어가서 EnemyType을  Mushroom선택해주고 각각 매핑해줌. 7개

> 15. Modifying The Data Table
- 에니메이션
1. Enemies폴더에서 Enemy_BP폴더 추가
2. 그 폴더들어가서 우클릭 - BluePrint 클래스 추가- 부모는 papaerCharacter.  이름은 Enemy.  더블클릭
3. 블루프린트의 Sprite선택하고 Details의 Sprite - mushroomidle선택
4. Transform - Scale  비율유지(좌물쇠) 한다음 3.5
5. Capsule선택하고 Capsule Half height 54로 하라고했지만 나는 65로함.  나중에 머리 충돌때 63으로 바꿈
6. 스프라이트 움직여서 캡슐크기에 들어가게 하기
7. 컴파일

- 블루프린트
1. 레벨에 배치(Y는 0으로)
2. Enemy블루프린트의 Viewport부분 들어가서 변수추가
   1.  변수타입 : ListofEnemy
   2.  변수명 : enemyType
   3.  defaultValue : MushroomEnemy
3. Event BeginPlay빼고 다 지우기
4. getDataTableRowNames함수 호출
5. forEachLoop호출. getDataTableRowNames함수의 끝을 Exec에 연결
6. ArrayElement를 getDataTableRow에 연결. DataTable은 EnemyDataTable 테이블 선택. 시작에 선연결
7. outRow  Split하기
8. enemyType변수 get으로 가져와서 Equal(Enum)함수 호출
9. 한쪽은 테이블의 Out Row Enmy Type과 연결. //현재 적의 타입이 리스트를 반복문돌다가 이번의 적의 타입이면
10. Branch만들고 Row Found와 연결
11. Out Row Idle 변수로 등록. 이름은 EnemyIdle. Branch의 True와 연결
12. 테이블의 다른놈들도 반복해서 변수로 등록 하면서 줄줄줄 set이어붙이기
13. 만든영역 지정하고 c눌러서 Set up enemy flipbooks 라는 이름으로 영역 정의


> 16. Creating The Enmy Pt1  벽까지 이동하고 부딪히면 더못가기
1. Event tick 정의
2. add custom Event 정의. 이름은 Handle Animation으로 변경
3. 또 add custom Event 정의. 이름은 Handle Movement
4. Event Tick끝에 Handle Animation호출 하고 또 그놈의 끝에서 Handle Movement호출

핸들에니메이션
1. Sprite 드래그 - Set Flipbook호출 - 
2. Character Movement 드래그 - get velocity호출 - vectorLength - greater - select - false의 리턴을 SetFlipbook의 New Flipbook과 연결
3. EnemyMoving Get으로 가져오고 Select의 True와연결
4. EnemyIdle Get으로 가져와서 Select의 False와 연결
5. HandleAnimation(빨간색)을 SEt Flipbook시작과 연결

6. MovementDirection 변수 추가(타입 : float)
   컴파일후 Default Value - Movement Direction 1.0 으로 변경
7. Handle Movement(빨간색) - Sequence연결
8. MovementDirection get으로 가져옴 - greater - Branch
9. Sequence Then0를 Branch시작 연결
10. Branch True에 SetActorRotation호출
11. 복붙해서 False와도 연결. False에는 New Rotaion Z값 180  //적이 쳐다보는 방향 반대로 변환.
12. Sequence Then1에 Add Movement Input호출. X값 1.0으로 변경.
13. Scale Value는 Movement Direction Get으로 가져와서 연결
14. 테스트 : 오른쪽 벽에 부딪히면 더 못가는지 확인 
15. Movement Direction 변수의 디폴트값을 -1로 바꾸고 왼쪽벽 확인

> 17. Creating The Enmy Pt2  벽에 부딪히면 방향전환해서 이동(패트롤)
1. Handle Movement(빨간색) - Add Movement Input 오른쪽에 - LineTraceByChannel함수 호출
2. 시작지점은 액터의 위치로.   GetActorLocation호출해서 Start와 연결
3. GetActorForwardVector호출해서 return Value - Multiply - 변수 Split 하고 - X변수 150으로 변경
4. GetActorLocation오른쪽에 Add하나 연결하고 방금만든 X변수와 연결
5. 그 값을 End에 연결
6. LineTraceByChannel의 Return Value는 Branch에 연결 - True는 Do Once
7. Character Movement드래그 - SetmaxWalkSpeed 디폴트0으로넣고 -  Delay - Duraion은 변수로 등록. 이름은 WaitTime
8. 컴파일하고 2.0초로 변경
//이동할수있는 최대속도를 0으로 만들고(즉, 제자리 멈추고) 2초있다가 원래 속력으로, 반대방향으로 이동하도록. 하며 방향변수값 반대로 저장
9. 또 Character Movement드래그 - SetmaxWalkSpeed 만들고 Deleay 의 Completed와 Set시작 연결
10. 이때의 MaxWalkSpeed변수 등록. 이름은 EnemyWalkSpeed로 바꿈
11. 컴파일하고 값은 400으로 변경

12. 제일최근 Set 3덩이 복사해서 앞에있는 Enemy BeginPlay(빨간색)로 가서 가운데에 끼워넣기
13. Character Movement의 Details에 있는 walk speed 검색해보면 600, 300 돼있는거 확인.

//현재 적 액터의 움직이는 방향 가져와서 반대로 바꾸고 저장
14. 가져왔던 Set 3덩이 오른쪽에 MovementDirection변수 Get으로 가져오고 
15. Multiply  -1.0
16. MovementDirection변수 Set으로 가져와서 연결.
17. MaxWalkSpeed Set의 마지막과 Set MovementDirection 시작 이어주기
18. Set의 오른쪽을 끌어서 Do Once의 Reset에 연결(선길다.)
19. (**중요**)선 더블클릭해서 보기좋게 아래로 이동
20. 테스트 : 완전 벽에 안붙고 방향전환함

- 디버깅. 수정
Draw Debug Type을 For Duration으로 변경하고 X값 줄여보기 75.
MovementDirection변수의 Details에서 Instance Editable 체크,  Expose on Spawn 체크

- 땅이 없는곳에서 떨어지지 않고 방향 전환 6:25
1. HandleMovement(빨간색)의 Sequence then1의 AddMovementInput 오른쪽놈 다 오른쪽으로 밀어서 공간 확보
2. MultilineTraceByChannel(땅인지 체크해서 라인따라 걷던것) 묶음   영역커맨트지정  : check for Wall\
3. 매우비슷하니 복사해서 바로밑에 붙여넣기
4. Actor의 위치 가져오는곳에 -(substract)  z에 100을 넣고 Add pin에 연결
5. Branch만들고 False를 DoOnce와 연결
//자기가 바라보고있는 방향으로 x축(가로) 75, z축(세로) 100 의 포지션이 false면 (아무것도 없단 말인듯) 방향 틀어라.


> 18. Createing a HUD For The Players Health(11분. 체력바 화면에 보이기)
1. 다운받은 에셋에서 Hearts폴더 Sprites하위로 가지고오기 
2. 2d Sprite로 변경
3. 2DPlatformerBluprints폴더 / User Interface - Widget Bluprint   이름 : Heart_WB   (위젯 블루프린트 약자)
   1. 더블클릭으로 위젯 블루프린트 열기
   2. Canvas Panel이 있는데 나는 없어서 추가해줌. 
   3. 그안에 image 드래그앤드랍
   4. Details에 Brush / Image 에서 heart검색해서 이미지로드
   5. 가로로 찌그러졌는데 Size Y 100으로 바꾸기
   6. Position X와 Y: 0으로변경.    객체이름 Fullheart로 변경   //화면 최 상단 왼쪽에 하트 표시
   7. Fullheart 복사해서 Canvas Panel에서 붙여넣기.  이름 Noheart로 변경. 이미지는 heartbackground로 변경
   8. 컴파일
4. 캐릭터 블루프린트
   1. 변수추가. 이름  : Health    타입 : Float.    기본값 : 5
5. 또 위젯 블루프린트 추가(플레이어 HUD)
   1. 이름 : playerthud_WB
   2. 캔버스 패널 추가
   3. wrap box 추가.  Details 에 Anchors 있는데 상단위 그림선택
   4. wrap 검색 Explicit Wrap Size 체크하고  1500으로 변경
   5. 오른쪽 위 Graph 패털로 이동
   6. Event Construct만 남기고 지우기
   7. Event Construct에서 Cast To 2dCharacter 호출.   Object는 get Player Character 호출
   8. As 2d Character는 변수등록.  이름은 2DCharacter  자동으로 만들어진 

6. 캐릭터 블루프린트의 Construction Script 탭
   1. 변수추가. 이름은 HeartContainers  타입은 Integer
   2. set으로 끌어오기. helth를 get으로 끌어와서 연결
   3. Construction Script의 오른쪽과 SET  왼쪽 연결

7. 다시 PlayerHud.  체력바를 현재 체력으로 채우기
   1. SET 오른쪽 for Each Loop
   2. First Index는 1   //0부터 할거냐 1부터할거냐
   3. SET 2DCharacter오른쪽을 get heart containers 호출하고 그놈을 Last Index에 연결
   4. Loop Body는 Create Widget 호출
   5. Class변수는 Heart_WB 로 세팅
   6. Desiner탭으로 가서 가운데위에 설정했던 영역 선택하고 Details제일위에 Is Variable 체크
   7. 다시 Graph탭으로 와서 변수에 추가된 WrapBox_1을 Get으로 가져오기
   8. Add Child to Wrap Box 호출
   9. Create Heart WB Widget의 return value를 Content에 연결
   10. HeartRef 변수 추가( 타입: Heart WB) 타입옆의 아이콘 클릭해서 Array로 변경
   11. get으로 가져오기
   12. add(파란색)호출
   13. Create Heart WB Widget의 Return Value를 ADD의 Select Asset과 연결
   14. Create Heart WB Widget의 끝을 ADD의 시작과 연결
   15. ADD의 끝을 Add Child to Wrap Box와 연결
   16. 컴파일

8. 캐릭터 Event Graph
   1. Event BeginPlay(빨간색)의 SET오른쪽에 create Widget연결
   2. 클래스는 playerhudWB
   3. 리턴벨류 변수등록. 이름은 playerhud
   4. Playerhud변수 오른쪽에 AddtoViewport함수호출
   5. 컴파일
   6. 테스트 : 검은색 하트 5개가 스크린에 보임
9. 디버깅
   1.  Heart_WB열어서 Fullheart를 Noheart밑으로   //오 신기하게 언리얼은 밑이 더 최신으로 인지하는듯
   2.  Fullheart 오른쪽 Details에서 ZOrder가 있느데 위에꺼만으로 이거 변경없이 되어서 안만진듯.
   3.  이제 화면에 빨간색 하트 5개 보인다.
   4.  캐릭터의 Health의 디폴트값을 10으로 바꾸면 10칸에서 시작.


> 19. Setting Up What Happens When The Player Is Damaged  플레이어가 데미지 받으면 체력감소
1. Heart_WB의 Event Graph
   1. add Custom Event    이름:Removeheart
      1. Fullheart get으로 가져오기
      2. set Visibility함수 호출.   hidden으로 세팅
      3. 컴파일
2. 2dCharacter 
   1. eventAnyDamage(빨간색) 호출
   2. health변수 get으로 가져오고 substract호출.  값은 1
   3. substract오른쪽을 health변수 set가져와서 연결
   4. eventAnyDamage(빨간색) 끝을 set으로 가져온 health 시작과 연결
   5. 컴파일
3. Playerhud_WB
   1. add Custom Event(빨간색)  등록.  이름은 Updatehealth
   2. HeartRef  get으로 가져오기
   3. for each loop 호출.   Updatehealth오른쪽도 이놈이랑 연결
      1. ArrayIndex에서 Equals호출
   4. HeartRef  get으로 가져오기
      1. lenght와 연결
      2. -로 substract검색해서 호출.  값은 1
      3. Equlas아래와 연결
   5. Equals 오른쪽 Branch연결.  앞의 LoopBody와 연결
   6. for Each Loop의 Array Element는 Removeheart호출
      1. branch True일때와 연결
   7. Heart Ref get으로 가져오기
      1. Remove호출
      2. RemoveItem() 호출
      3. Select Asset은 반복문의 ArrayElement와 연결
      4. removeheart 의 끝을 RemoveItem()의 시작과 연결
      5. 컴파일
4. 2dCharacter
   1. EventAnyDamage맨오른쪽에 playerhud get으로 가져오고 
   2. updatehealth()호출
   3. Set의 끝과 연결
   4. 우클릭 1로 키보드1키입력 - Pressed와 Set시작 연결
   5. 컴파일
   6. 테스트 : 1키 누르면 체력 깎임


> 20. Creating A Screen Shake Effect 화면 흔들거리기  (2:59)
흔들리는 카메라 생성
1. 2DPlatformBlueprints 폴더에서 BlueprintClass 새로생성.  MatineeCameraShake 클래스 선택.  이름은 DamagedCameraShake
2. 더블클릭으로 들어가서 Oscillation Duration 0.25로 변경
3. Rot Oscillation(Rotation에 의한 진동)
   1. Pitch    Amplitude(강도) 5,  Frequency(속도) 50
   2. Yaw      Amplitude 5,  Frequency 50
4. Loc Oscillation(Location에 의한 진동)
   1. Z의 Amplitude 100,  Frequency 1

2dCharacter 블루프린트
1. 1번눌렀을때와 연결된 Updatehealth의 끝에서 play Wolrd Camera Shake()호출
   1. Shake에 Damaged CameraShake 지정
   2. Epicenter는 getActorLocation호출해서 연결
   3. Outer Radius 1000으로 변경
   4. 테스트

> 21. Setting Up Mellee Attack Pt 1(근접공격설정1  5:43)
애니메이션 만들기
1. Sprites/PlayerCharacterSprites/Attack 에 10, 11, 12 지우고 애니메이션 작업
2. Edit - ProjectSettings - Engine - Input 에서 MeleeAttack으로 Left Mout Button
                     ProjectileAttack으로 키보드 x키
캐릭터 블루프린트
어택키 눌렀을때의 상태변화
1. Attack 검색해서 InputAction MeleeAttack가져오고 
2. Wallslide? 변수 get으로 가져오고 or 연결
3. Character Movement 컴포넌트 가져오고 isFalling()호출
4. isFalling()의 결과를 OR 밑에 연결 하고 OR의 결과를 Branch에 연결
5. isAttacking? 불변수 추가
6. isAttacking? set으로 가져와서 branch의 False와 연결.  체크박스 체크  //벽을 타고있을때는 공격적인 상태값을 줘서 다시 공격못내리게 할려는듯

어택키 눌렀을때 에니메이션 호출
7. handleAnimation영역의 UpdateAnimation(빨간색)의 제일오른쪽밑 Set Capsule Radius 오른쪽에 공간만들고 끼워넣을거다.
8. isAttacking의 상태가 아닐때만 원래하던 묶음 호출로
9. true는 연결 끊고 SetFlipbook호출하고 Attack애니메이션 연동
10. 그 플립북을 변수로 뽑아내서 이름 AttackingAnimation으로 하고 Animation카테고리에 넣기

공격시간 몇초인지 찍어보기
InputAction MeleeAttack (빨간색)의 제일 끝 Set으로 가서 AttackingAnimation Get으로 가져오고 GetTotalDuration을 PrintString
0.6초나옴
근데 무한 공격함
delay()호출 0.5초   뒤에 Set Is Attacing false로 만들기
//즉 공격키 누르면 0.6초동안 공격애니메이션 나오고  공격키 누른다음 0.5초뒤에 재공격 가능상태로됨

> 22. Setting Up Mellee Attack Pt 2(근접공격설정2   3:40)
캐릭터 블루프린트
1. delay에 하나더 끌어서 Sequence호출
   1. Then0에는 원래 Set연결
   2. Then1에는 LineTraceForOjbect()호출
   3. 시작지점은 액터의위치 GetActorLoation()
   4. GetActorForwardVector, Multiply쪼개서  X축 바라보는방향으로 100
   5. add함수 호출하고 연결.   add결과를 End와 연결
   6. 에너미 블루프린트 View탭 들어가서  - Capsule - Details에 보면 Collision Presets 값이 Pawn으로 설정되어 있는거 확인
      1. Object Types은 끌어서 Make Array - pawn선택
   7. 캐릭터의 View탭 들어가서 Collision Presets값이 Pawn으로 설정되어있는거 확인
      1. Actors to Ignore는  끌어서 Make Array - pawn선택
      2. Array[0] 끌어서 self
   8. OutHit은 break 검색해서 Break Hit Result호출. 아래 펼치고
      1. Hit Actor는 Apply Damage()호출
      2. BaseDamage 1로 변경
      3. 흰선 연결
      4. 맞는대상 프린트 찍어보기

> 23. Setting Up Ranged Attack (원거리 공격설정 8:05)
1. 오브젝트 가져오기
   1. Asset에 있는 Objects의 Axe를  Sprites/Objects에 붙여넣기
   2. 2D로 바꾸고 Sprite로 바꾸고
2. 도끼 블루프린트 생성
   1. 2DPlatformerBluprints폴더에서 우클릭 Blueprint Class 생성.   타입은 Actor. 이름은 Axe
   2. 컴포넌트에서 Add Paper Sprite
   3. Details에서 Sprite변경
   4. Scale 비율유지하면 2로 키움
   5. Add Projectile Movement 추가
   6. Initial Speed 200, Max Speed 500으로 설정
   7. Projectile 선택하고 Details에서 gravity 확인해보면 1.0
   8. 시뮬레이션 하는데 나는 안된다.(2분5초)
   9. 초기속도 500, gravity 0으로 수정
   10. Add RotatingMovement 추가
   11. PaperSprite에서 회전시켜보면 Y가 변하는거 확인하고  RotationMovement의 RotationRate가서 X 0, Y 180, Z 0으로 변경 (3분30초)
   12. 반대로 도는거 보고 -180으로 변경
3. 캐릭터와 도끼 관계(캐릭터 블루프린트)
   1. 캐릭터가 원거리 공격 키를 누르면 도끼가 호출되어야 함.
   2. 빈곳에 projectileAttack(빨간색) 호출
      1. SpawnActor 호출하고 Class에 Axe선택
      2. Transform은 쪼개고
      3. 뷰포트로 돌아와 캐릭터 컴포넌트의 SpringArm밑에 Scene추가 이름은 AxeSpawn
      4. 위치를 도끼가 나올곳으로 조정
      5. EventGraph로 돌아와 AxeSpawn 드래그, getWorldLocation()호출.  Return Value를 쪼갠 Transform Location에 연결
      6. 오른쪽이면 오른쪽으로 던져야하고, 회전도 시계방향.   왼쪽이면 왼쪽으로 던져야하고 회전은 역시계방향이여야 함
      7. ismovingright? get으로 가져오고 select와연결. Select의 Return Value를 쪼갠 Transform Rotation과 연결
         1. Flase의 Z를 -180으로
   3. 테스트.
      1. x누르면 날라가는데 크기가 너무작음. 5로 변경
      2. 초기속도 1000, 맥스속도 1000으로 변경
      3. rotate는 -180에서 -500으로 변경
   4. 누를때마다 날라가는데 수정할것임
      1. float변수 추가 이름은 NumberofAxes
      2. 컴파일후 초기값 10
      3. 원격공격키 눌렀을때 체크해야됨. get으로 가져와서 greater>0(현재 남아있는 도끼가 있으면)  이면 branch - SpawnActor Axe
      4. 스폰하고 나면 1개 빼야지  get으로 가져와서 subtract 에 1해주고 set 해주고  SpawnActor와 연결시켜주기
   5. 끝. 현재 도끼랑 충돌나면 비비다가 뚫고가는 버그있음

> 24. Hud에 발사체 표시하기  (4:25)
Playerhud_WB
1. 뷰에 Horizontal Box  Panel생성하고 왼쪽위에 배치. 
2. 3개의 text배치하고 Horizontal Box밑에 넣기
3. image 1개 Horizontal Box밑에 넣기
4. 뷰에 첫번째 Text선택하고 Details의 Content에 Bind있음
5. 2DCharacter - Numberofaxes 선택
6. 두번째는 /
7. 세번째는 MaxAxes선택   (안나와서 찾아보니 강의에 없었는데... 그래서 만들어주고옴.  그래도 안나오네)
   1. //연두색이 변수인데 도끼관련 없네
   2. https://www.udemy.com/course/learn-how-to-make-a-2d-platformer-in-unreal-engine/learn/lecture/31037260#questions/17185634
   3. 5버전에서는 조금이상한 변수를 안띄워주도록 패치됐나봄. float를 int로 바꾸니까 됨. 본질적으로 더 맞다.
8. 이미지는 Axe선택해주고 가로 50정도로 비율맞게 조정
9.  글자들마다 Right padding 10주기
10. 테스트(2:10) 난 숫자가 안박혀있네. 다시한번 반복하고 정상완료. 
11. 텍스트 클릭하고 Text내용에 ?Text Block"이라고 적혀있던거 지우고 Size에 Fill 누르고 가로정렬 왼쪽, 가운데, 오른쪽.   이미지 없애고 패널 좁히기
    //5버전에서는 매핑이 돼있으니 저절로 사라지고 없앨수가 없네.
12. 패널 바로 오른쪽에 이미지 넣고 크기 조정

>25. Adding Projectile Pick Up(투사제 춥기. 4:51)
땅에 떨어진 도끼 만들기
1. 블루프린트 추가.   유형 : Actor   이름 : Axe_Pickup
2. 들어가서 컴포넌트 - Add - PaperSprite
   1. Source Sprite 도끼로 변경
   2. Scale 5로 변경
   3. Collision Presets 값을 BlockAllDynamic에서 NoColliision으로 변경
3. Add - BoxCollision   이름
   1. Box Extend  크기 32이였는데 그대로
   2. 밑에내려보면 Events에 초록색 버튼에서
      1. 2번째 On Component Begin Overlap 클릭
   3. 블루프린트로 넘어가진다. Other Actor에 Cast To 2dCharacter호출
   4. As 2d Character 끌어서 Set NumberofAxes
   5. 변수추가   noOfAxes(도끼갯수).   no인줄알았는데 number의 의미였구나.    타입 : float로 하라하는데 나는 int로
   6. 컴파일하고 Instace Editable , Expose on Spawn 체크
   7. 디폴트값 2로 바꾸고 화면에 배치
   8. CastTo2dCharacter의 as 2d Character 오른쪽 또 끌어서 get NumberofAxes호출
      1. noOfAxes get으로 가져와서 Add와 연결하고 그놈의 에서 만든놈과 연결
      2.  //즉 주운것과 현재있는것들 더해서 SET해주는작업인데 Max를 넘지 않아야 되기 때문에 아래작업 할것
      3.  clamp함수 호출하고 return을 set과 연결   //inclusive작업
   9.  CastTo2dCharacter의 as 2d Character 오른쪽 또 끌어서 get Max Axes호출
       1. max를 방금만든 max로 연결
4. 테스트  4에서 먹을때마다 주운도끼 안없어지고 Axe_Pickup의 디폴트값 만큼 증가됨.
5. SET뒤에 destroy 호출하면 먹고 없어짐

>색션5. Creating A Damage System
> 26. Damaging The Enemy(적에게 피해 입히기. 7:11)
1. Sprites/Enemy 폴더를 Content하위로
2. EnemyStructure 열고 변수추가. EnemyHealth   float   save
3. EnemyDataTable 열고 머쉬룸 체력 5로 지정

에너미 블루프린트
1. 빈곳에  Evevt AnyDamage(빨간색)
2. 예전에 테이블에서 줄줄이 이었던 getDataTable부분 보면 방금추가한 Enemy Health추가돼있다.
3. 변수로 뽑기. 이름은 EnemyHealth.
4. 마찬가지로 set으로 불러와서 이어주자.
5. 데미지 받는 이벤트가 일어나면 현재체력-데미지 계산해주기
   1. Enemy Health Get으로 가져와서 subtract호출. Event Anmydamage(빨간색)의 Damage와 연결
   2. 결과를 EnemyHalth Set호출과 연결시키고   Event Anmydamage(빨간색)의 오른쪽을 Set처음과 연결
6. 뭐할지 결정
   1. Set에서 LaunchCharacter()호출.  속도는 쪼개기
   2. xy,  z  Override 체크
   3. Velocity X는  multiply호출해서 -1500

캐릭터 블루프린트
1. ApplyDamage의 Damage Causer(데미지 제공자) : Self 호출
2. 컴파일

다시 에너지 블루프린트
데미지유발자(캐릭터)의 위치와 피격자(에너미)의 위치를 벡터 노멀라이즈 해서 x가 0보다 작은게 아니면(오른쪽으로 보고 있다면) x축으로 -1500더하기
1. Evevt AnyDamage(빨간색)의 Damage Causer 에서 get Actor Location() 호출
2. get Actor Location() 하나더 호출하고 GetUnitDirection()호출해서 from to 연결
3. return에는 normalize연결
4. 리턴 쪼개기
   1. x는 less 호출 - select연결 - False값 -1로 바꾸고 의 Return Value를 아까 multiply의 위쪽으로 전달
5. 컴파일후 테스트 : 공격받으면 반대방향으로 조금 튕겨나감

> 27. 적피해 플립북 업데이트
1. Enemy의 Event AnyDamage(빨간색)에 연결된 Launch Character 오른쪽에 branch호출
2. 적의체력이 0보다 작은상태라면 공격안받게 할것임
   1. enemyHealth변수 가져와서 <= 호출. branch와 연결
   2. enemyDamaged? 변수추가.
   3. set으로 가져와서 Branch의 False와 연결.  enemyDamaged? 체크박스 체크
3. 0.2초간 공격받고있는 상태로 변환
   1. EnemyDamaged get으로 가져와서 GetTotalDuration호출
   3. Retriggerable Delay()호출.
   4. Set과 연결
   5. Retriggerable Delay뒤에는 Enemydamaged?변수상태 False로 해주기  (set으로 가져와서 체크해제)
4. 에니메이션
   1. Handle Animation 왼쪽으로 옮겨서 공간만들고
   2. 공격받고있는 상태가 아닐때만 원래 플립북 연결.    branch만들고 enemyDamaged? get으로 가져와서 연결.   False와 원래 흰선 이어줌
   3. sprite와  setFlipbook 세트 가져와서 EnemyDamaged플립북 가져와서 이어줌
   4. True와 이어줌
5. 컴파일하고 테스트.   빛나면서 뒤로밀리는 애니메이션나고 위치도 이동.
6. 애니메이션 수정
   1. 흰색부분 duplicate해서 한프레임 늘려줌

> 28. 도끼 투사체 피해(4:52)
도끼 블루프린트(2DPlatformerBlueprints/Axe)
1. Component추가. Sphere Collision.   Details에 Sphere Radius 40으로 변경   (0:54)
2. Collision Presets 를 NOCollision으로 변경
이벤트처리
3. 밑의 Event 에서 2번째 On Component Begin Overlay 초록색 + 버튼
4. Other Actor에서 Apply Damage()
   1. BaseDamage 1로
   2. DestroyActor
캐릭터나 다른도끼에 부딛힌것이 아니라면 데미지주기
//뭔가 했다가 다 지워버리고 이 아래방법으로 다시함
5. Other Actor에 Actor Has Tag연결
   1. Tag값으로 axe입력
   2. Return Value로 Branch연결
6. Axe의 Details에서 tag검색
   1.  +버튼 누르고 axe 입력
   2.  컴파일
7. 2dCharacter 블루프린트에서 tag검색
   1.  +버튼 누르고 axe 입력
   2.  컴파일
8. 2dCharacter 의 SpawnActer Axe밑에 펼치기 하면 Owner나옴.
   1. 끌어서 self연결

Axe
1. ApplyDamage의 Damage Causer로 Get Owner연결
2. On Component Begin Overlap(Sphere) 빨간색  의 Other Actor와 Apply Damage(파란색) 의 Damaged Actor연결
3. 컴파일후 테스트.   나는 적이 안맞고 뚫고가버림
4. https://www.udemy.com/course/learn-how-to-make-a-2d-platformer-in-unreal-engine/learn/lecture/31037278#questions/17276686 
5. 여기보고 초록색 이벤트를 Sphere에서 안만들고 PaperSprite에서 만든걸로 바꿔줌.


> 29. 적 사망 시스템 만들기
현재도 5대맞으면 죽은 상태로 변수값은 측정되는데 에니메이션은 계속 걸어오면서 공격도 계속 먹히는 상황임
Enemy
1. 적체력 0이하면 Branch True부분
   1. EnemyDead 변수추가
   2. Set으로 가져와서 연결. 체크.
2. HandleAnimation(빨간색) 왼쪽으로 길게빼서 영역 만들어주기
3. 적이 죽은상태가 아닐때만 기존의 프로세스 작동
   1. Branch
   2. EnemyDead get으로 가져오기
   3. 원래 Branch와 연결
4. 죽었을때는 죽어있는 에니메이션 보여주기
   1. EnemyDeadBody? 변수 Boolean 으로 추가
   2. get으로 가져오기
   3. select에 호출. 
      1. SetFlipbook호출. 타겟 Sprite연결
      2. 새로운 플립북은 Select의 리턴값과 연결
   4. Branch의 True를 SetFlipbook에 연결
   5. Select의 False에는 EnemyDie에니메이션 연결
   6. Select의 Trud일때는 EnemyDeadBody에니메이션 연결
5. 다시 적체력 0이하면 Branch True에 죽은상태로 만들기부분
   1. 죽은상태 몇초유지할것인지 설정
   2. EnemyDie 플립북 get으로 가져오기
   3. getTotalDuraion
   4. delay()
   5. EnemyDeadBody? Set 으로 가져와서 체크
6. Branch와 Set 사이 DoOnce()호출
7. Handle Movement의 Sequence.  죽은상태가 아닐때만 방향쪽으로 이동
   1. Then1을 끌어서 Branch
   2. Enemydamaged? get으로 호출
   3. EnemyDead get으로 호출
   4. 두개 or로 잇고 결과를 Branch에 연결
   5. 그럼 Branch의 False가 기존의 AddMovementInput(파랑)과 연결
8. 테스트. 성공. 5대때리면 시체됨(3:35)
9. EnemyDataTable에서 버섯 체력 1로 변경
10. 시체는 죽는에니메이션의 총시간에서 0.4초 후에 시체상태로 변환
    1.  EventAnyDamage의 EnemyDie의 GetTotalDuration 끌어서 subtract 0.4
    2.  위의 DelayDuration에 연결

> 30. Createing A Jump Attack System. (점프로 머리찍기 공격)
캐릭터 블루프린트
1. 2dCharacter의 Character Movement 에서 plane 검색. 
   1. Constrain to Plane 체크
   2. Plane Contraint Axis Setting  Y로 체크
2. Enemy의 Character Movement도 마찬가지 체크해주기.
3. 이제 계속 밟고다닌다. 이전에는 충돌 애러나서 땅으로 떨어졌음
4. Enemy 의 Viewport에서 컴포넌트추가. BoxCollision
   1. Details에 Shape의 박스모양을 납닥한 위에 머리모양으로 맞춰줌.  32, 32, 14
   2. ? 근데 이 모양과 상관없는데 실제 크기는??
5. Event에서 2번째 클릭. On Component Begin Overlay    //여기 복잡하다..
   오버레이 됐을때의 상대엑터가 캐릭터고 떨어지는 상태라면 위로 뜨기
   1. Other Actor - Cast to 2dCharacter
      1. as 2d Character - get Character Movement - is Falling - branch
      2. Cast to 2dCharacter 와 Branch 연결
      3. Branch True면 LaunchCharacter 호출.  Z축 400(밟고 튀어오르는 높이),   XYZ Override 체크
   적 데미지 받기
   2. Enemy 블루프린트 EventAnyDamage(빨간색) 영역
      1. Add CustomEvent   이름 : Jumpdamage
      2. Do Once 호출하는 Branch와 연결
      3. //이건 점프하면 적 바로 죽이는건데??... 이걸 한다고?
   3. 다시 OnComponentBeginOverlap(Box. 빨간색) 영역으로 가서 캐릭터 z축으로 400(밟고 튀어오르는 높이)이동하는곳 뒤에
      1. EnemyHealth  가져와서 subtract - 
         1. 2dCharacter에 Jumpdamage변수 float으로 추가. 컴파일후 디폴트 데미지5.
         2. 다시 Enemy 블루프린트로와서 Cast to 2dCharacter(청록)의 As 2d Character 끌어서 jumpDamage get으로 가져오기
         3. 그 Subtract 의 결과로 Enemy Health Set해주기
         4. Branch True는 이 Set과 연결
         5. set 이후에 Jumpdamage - Launch Character
   4. 테스트. 버섯 밟으면 죽는데  //이것도 잘안죽음.  아 버섯머리 튀어나온부분이 모자보다 더 튀어나와서 거기밟으면 안죽네.  ㅇㅋ 캡슐크기에 딱맞기보다 조금더 높이 조금더 크게 사각크기조정해서 해결함
      시체에서 계속 방방뜀.
   5. 방방뛰는거 해결
      1. EventAnyDamage 에서 죽었을때 Do Once 위에 Box 드래그앤드랍 - DestroyComponent()
      2. Do Once와 연결
      3. 끊어진 SET 다시 이어주기
   6. 테스트.
      1. 스스로 주인공 점프 700으로 조정.   튕겨오르는 높이 400으로 조정

> 31. Making The Enemy Damage The Player Character( 적이 플레이어에게 데미지)
Enemy
적이 공격할 범위 만들거임
1. 컴포넌트 - Box Collision 추가. 이름은 Attackbox
2. 자기크기만큼 옆에다가 배치
3. 또 2번째 Event추가(On Component Begin Overlap)
   1. Cast To 2dCharacter - Set Timer By Event - 리턴우클릭 Promote 변수  AttackEvent
   2. 시간은 0.1초
   3. Looping 체크
   4. Event에는 Add Custom Event 해서 이름 AttackPlayer라고 지어주기
   5. AttackPlayer - Branch - 조건 EnemyDead Get으로 - False는 Do Once
   6. 변수선언 isattacking?
   7. isattacking? Set으로 가져와서 체크하고  Do Once의 Completed와 연결
4. 3번째 이벤트도 추가(On Component End Overlap)
5. ~2:45

HandleAnimation부분
//죽은상태가 아니고 공격받은 상태가 아니고 Isattacking? true일때는 공격하는 애니메이션
1. 가운데브런치 오른쪽 공간 좀 확보해주고
2. False에 Branch연결. IsAttacking? get으로 연결
3. False면 원래 행동
4. True면 setFlipbook - 타겟은 Sprite , 플립북은 EnemyAttacking

다시 On Component Begin Overlap의 맨 끝
공격상태값을 true로 바꾸고 나서 
시퀀스1. 적공격 애니메이션의 시간이후에 공격상태값 false로 바꾸기
시퀀스2. 원래대로 이동
1. set Isattacking? 쪽으로 가서
2. EnemyAttacking get으로 가져오고, GetTotalDuration()
3. SET은 Dealy() 호출하고 시간 연결
4. Sequence
   1. Then0에는 is Attacking Set으로 가져와서 체크안함
   2. Then1에는 LinetraceforObject
      1. Start는 GetActorLocation
      2. GetActorForwardVector - multiply - split - x에 100
      3. GetActorLocation과 방금구한거 Add
      4. 그놈을 End에 연결
   3. ObjectType은 MakeArray에 Pawn
   4. Actors to Ignore는 MakeArray에 Self
   5. Debug는 for duration
   6. Out Hit은 break hit result
//친놈이 플레이어면 
5. Break Hit Result의 Hit Actor - Equals - getPlayerCharacter
6. Branch 시작을 LinetraceforObject끝을 연결
7. Branch True를 ApplyDamage() - Damaged Actor는 아까 Hit Actor에서 하나더빼서 연결
8. Base Damage는 변수로빼기 enemydamage   float
   1. Instance Editable, Expose on Spawn에 체크
   2. 컴파일후 디폴트값 1(적의 기본공격력)
9. Delay()주고 Duration은 변수로 뽑고 이름 cooldown  값은 0.3
10. Complete는 길게 끌어서 초반부의 DoOnce의 Reset에 연결
11. 선 잘보이게 변경
12. 마지막 Branch의 False도 Dealy와 연결하는데 왜그러는지 이해안됨


캐릭터(7분)
오른쪽 Event AnyDamage
1. 드디어 만들어놨던 체력에서 데미지를 -에 전달

(8분 30)
On Component End Overlap(빨간색) 이벤트 만들어놨던거. 어택영역에 오버랩이 끝나면
1. Other Actor - CaseTo2dCharacter - (clear로 검색)Clear and Invalidate Timer By Handle
   1. AttackEvent get으로 가져와서 Handle에 연결
   2. Handle의 끝은 DoOnce의 Reset
2. 컴파일후 테스트 잘됨. 공격하고 맞으면 번쩍이며 1깎이고 0.3초있다가 재공격
3. 적 인스턴스의 공격데미지를 높여도 제대로 반영안돼서 수정
   1. 플레이어 - EventAnyDamage(빨간색) 부분
   2. Playhud와 연결된 UpdateHealth 연결 끊어서 잠시 분리
   3. SetHealt 끝나면 카메라 흔들리기로 연결
   4. 카메라 흔들리고 나면 For Loop호출
   5. FirstIndex는 1,  LastIndex에 이벤트 들어온 Damage연결
   6. 생겨난 Truncate보기좋게 밑으로 내림
   7. ForLoop뒤에 playHud에 유저체력수정 연결
4. 11:53 테스트 끝

Enemy
1. canmove?  Boolean 변수추가.   Instance Editable, Expose on Spawn 체크
2. handleMovement의 OR 부분가서 addpin.
3. Isattacing? 끼워넣기
4. Sequence와 연결된 Branch위에 또 Branch추가.  //움직일수있는 상태일때만 원래하던 그쪽방향으로 이동하던거 계속
5. 이제 인스턴스마다 움직이는놈, 안움직이는놈 체크해줄수 있음

> 32. Where to Get 2d Sprite (2d Sprite를 얻기위해 어디로 가야하나)
- itch.io  Select a tag 에 2d,  platformer 검색
- opengameart.org

>33. Creating A Ranged Emymy Pt 1(12:00)
0. 커맨트 정리
1. Enemy블루프린트 Duplicate해서 RangedEnemy
2. 캐릭터가 있는 방향을 계속 쳐다보게 할거다.
   1. handle Movement 다 지우고 handle Rotation으로 이름변경
   2. 데미지받았을때의 밑의 부분(노멀라이즈 하는부분) 복붙
   3. 앞에다 플레이어캐릭터 연결. (getPlayerCharacter)
   4. 만약 branch연결. 조건으로 아래에 복붙해온거 연결
   5. true면 setActorRotation
   6. false면 setActorRotaion z축 180
   7. 화면에 배치하고 테스트.  근데 나는 화면에 안나오네.. 아 setActorLocation을 호출했었네.
3. 공격(5:20)
   1. 어택할 박스 범위 수정(짧은 활 정도 공격할수있도록)
   2. 2번째이벤트 버튼 클릭해서 오버레이 begin으로 이동
   3. 오버레이 end부분 제거
   4. doOnce뒤로 다 제거
   5. 죽은상태가 아니라면 (Branch False에서 이어붙이기) - do Once - isAttacking? True로 만들기(setIsAttacing 체크)
      1. 이 블루프린트에서는 더 적절한 이름으로 변경 isRangedAttacking?
   6. 다른영역의 isRangedAttacking? 이 true면 실행하는 에니메이션 부분 변경. EnemyAttacking 플립북 대신 EnemyRangedAttacking으로
   7. 다시 비긴오버레이의 set isRangedAttacking?뒤에 원거리공격 에니메이션 시간뒤에 투사체 발사
      getEnemyRangedAttack 플립북 - getTotalDuration - Delay() - SpawnActorFromClass (밑에걸 해야 완성되기 때문에 현재로서는 컴파일에러)
   8. 투사체 에니메이션 만들기
      1. Content/Enemies/Mushroom의 Projectile 폴더에서 하던작업.  가로50으로 자르기. 이름은 mushroomProjectile
      2. 근데 플립북으로 안만들고 첫번재 스프라이트 이름을 mushroomprojectile으로 변경
      3. 2DPlatformerBluprints에서 만들었던 Axe 복사해서 Enemy_BP폴더에 붙여넣고 이걸 수정할거다.  이름은 MushroomProjectile (8:40)
      4. 뷰포트 - 컴포넌트 - ProjectileMovement 에서 초기속도 700, 최대속도 700으로 조정
      5. 이벤트 그래프의 Actor Has Tag의 태그값 enemy로 변경
      6. MushroomProjectile의 Details의 tag검색해서 마찬가지로 enemy로 변경
      7. Enemy블루프린트로 가서 Details의 tag검색해서  index추가해서 enemy
   9. 아까 넘어왔던 SpawnActorFromClass
      1.  Class는 머쉬룸프로젝타일
      2.  Spwan Tranform은 쪼개기
      3.  뷰포트로 가서 Add Component    Scene.  이름은 ProjectileSpawnLoc
      4.  위치는 입앞 정도로 조정
      5.  다시 이벤트그래프로 와서 get으로 가져오고 - 그놈의 getWorldLocation을 Spawn Transform Location에 연결
      6.  getActorRotation을 Spawn Transform Rotation과 연결
      7.  끝났으면 공격상태는 false로 변환  (set isRangedAttackin? 체크해제) 
      8.  Delay()  cooldown   - DoOnce의 Reset으로 길게연결
      9.  보기좋게 선정리
  1.  테스트 : 한번 범위에 들어오면 범위에서 벗어나도 원거리 공격하는 문제가 있지만 강의에서도 그럼.

>34. Creating A Ranged Emymy Pt 2(4:00)
원거리적군의 Cooldown은 3초로 수정
문제1 : 도끼가 캐릭터가 아니라 적의 공격범위로 들어가면 적이 죽음
   원거리적군 - Attackbox 컴포넌트 - Details - Collision Presets가 OverlapAllDynamic으로 돼있음
      Custom으로 바꾸기 - Object Responses 속성에 WorldStatic, WorldDynamic 이 Overlap이였는데 Ignore로 선택
      그럼 미약하지만 근접 Enemy도 마찬가지
   Axe 블루프린트 열어서 Sphere 컴포넌트 - Details - Collision Presets가 OverlapAll로 돼있음
   컴파일 후 테스트 : 완료
문제2 : 적의 투사체를 내 투사체로 막기가능(나는 안막아지고 내 도끼만 사라짐)
   Axe의 블루프린트로 가서  Other Actor 에  is Valid를 중간에 연결
   MushroomProjectile로 가서 Other Actor 에  is Valid를 중간에 연결
   강의는 그제서야 나랑 똑같아 지고 나는 원래대로임

>35. How to Add New Enemy Sprites(새로운 적추가. 고블린. 8:35)
1. 고블린 애니메이션 제작
   1. Enemies/Goblin 폴더에 폴더들 추가. Attack, Projectile, Death, RangedAttack, Idle, Run, Getdamaged
   2. 현재 사진들을 각각 폴더안으로 넣기
     RangedAttack폴더에 Goblinthrow
   3. 2dTexture로 바꾸고 - Extract Sprites하고 Grid 너비 150으로 추출.    플립북으로 만들기. 이름은 이름은 Goblin땡땡땡   으로 계속 변환
   4. death의 마지막은 GoblinDeadBody로 플립북하나 만들기
2. EnemyDataTable
   1. Add버튼 누르고  EnemyType은 고블린
   2. 각각 에니메이션 매핑
   3. 체력은 10
3. Enemy 블루프린트
   1. enemytype 변수. Details에 Instance Editable 선택, Expose on Spawn 선택
4. Ranged Enemy 블루프린트
   1. 마찬가지
5. 맵에 고블림 배치(4:50)
   1. 레벨에서  Enemytype을 고블린으로 해주면됨
6. 블루프린트 새로 안만들고 조금 수정해서 같이 쓰기
   1. RangedEnemy의 Setup Enemy Flipbook(도미노처럼 늘어선영역) - getDataTableRow 앞의 Set과의  연결 끊기
   2. 뒷부분 다 복사해서 Construction Script 탭에 붙여넣기
   3. Sprite컴포넌트 드래그해서 setFlipbook호출
      1. Enemy Idle플립북 연결
   4. Set후에 이어받기
   5. 위까지 똑같이 그냥  Enemy에도 해주기
7. 위에한거 뭔지 잘 모르겠음..
8. 고블린 인스턴스 데미지 2로 조정
9. Enemy 이벤트 그래프의 EnemyWalkspeed Details에서 instance Editable, Expose on Spawn 체크

>37. how to create a moving platform(캐릭터 외의 요소의 움직임)
1. 2DPlatformerBlueprints 폴더에서 우클릭 - 블루프린트 클래스 - Actor - MovingPlatform으로 이름
2. 컴포넌트 추가 - PaperSprite - 소스 스프라이트는 greysquare_Sprite
3. 긴 직사각형으로 크기 조정
4. 컴포넌트 추가 - Interp To Movement
   1. Details에 Behavior Type
   2. Details에 Control Point +버튼2번눌러서 2개 추가
   3. 변수2개추가  이름 : Location1, Location2   타입 : Vector
      1. 컴파일후 초기값 
      2. Instance Editable, Expose on Spawn, Show 3D Widget 체크
다시 블루프린트
1. 변수 추가.  이름 : Duration   float형  Instance Editable, Expose on Spawn 체크
2. Construction Script 탭
   1. InterpToMovement 컴포넌트 드래그
      1. Set Control Point 호출
      2. Control Points는 Make Array
      3. 0번인덱스는  Make InterpControlPoint 호출 - 위치로 Location1지정
      4. 1번인덱스는 Make InterpControlPoint 호출 - 위치로 Location2지정
   2. InterpToMovement에서 한줄더 호출 - Set Duration. 그앞의 SET과 흰선연결 //무브번트의 기간을 SET으로 설정
      1. Duration변수 가져와서 값대입
맵에 배치
1. 맵에 배치한다음 Location1 다이아몬드 선택해서 그림 왼쪽, Location2는 그림 오른쪽에 위치지정
2. Duration 10으로 값지정
3. 실행 : Location1부터 Location2까지 10초동안 이동한다.

>38. How to create a Coin System(코인줍기)
1. 동전 애니메이션 만들기
   1. Sprites에 Coin폴더 생성
   2. 요소폴더에서 Coin 폴더안에 넣기
   3. 맨날 하던걸로 애니메이션 만들고 이름은 Coin
2. 블루프린트 만들기
   1. 2DPlatformerBluprints 폴더에 블루프린트 클래스 - Actor  이름은 Coin
   2. PaperFlipbook 컴포넌트 추가하고 소스플립북 Coin으로 변경
   3. Sphere Collision 컴포넌트 추가하고 직경(Sphere Radius)이 너무 크니 10으로 바꿨는데 나는 그래도 커보여서 5로 변경
   4. 비긴오버랩 이벤트 호출
3. 캐릭터 블루프린트
   1. 변수추가   이름 : NoCoins,   Type : Float->  //NoCoins는 또 헷갈리는데 없다가 아니라 숫자다. 나는 int. 그래야 아래작업하는데서 보임
4. PlayerHud   화면에 동전먹은거 표시
   1. Horizontal Box  패널 추가.  안에 Text, Image추가
   2. Text의 Bind는 2dCharacter의 NoCoins
   3. Image Bind는 제일 큰 코인. 이미지 사이즈 적당하게 늘리기(50정도)
   4. 텍스트의 오른쪽패딩 10
   5. 테스트 : 동전그림앞에 숫자0있음 (3:40)
5. 동전 먹을수있는 기능
   1. Coin Actor의 비긴오버랩 - OtherActor - Cast To 2dCharacter
      1. As 2d Character - get No Coins - increment - set No Coin   //현재 갯수에 1더하기 그걸로 다시 가진코인갯수 세팅
      2. 캐릭터와 충돌해서 먹힌 이 동전은 없애기   - destroyActor
6. 화면에 배치후 테스트
   1. 코인이 너무작아서 5배로 키움. Coin 뷰포트 - 페이퍼플립북 들어가서 비율유지한채로 Scale 5
   2. 충돌 면적이 너무 작아서 강의처럼 32로 바꿔줌
7. 코인의 World배치를 MovingPlatform 하위로 넣으니 움직이는 요소에 같이 코인이 움직임
-> 우야가 캐릭터속도좀 빠르게 해달라고 해서 전반적으로 30% 정도 증가.

>39. How to create a Checkpoint System(체크포인트)
훨씬 어려운 공식사이트  : https://docs.unrealengine.com/4.27/ko/InteractiveExperiences/HowTo/RespawnPlayer/Blueprints/
캐릭터가 죽으면 마지막 저장지점에서 풀피로 태어나기
캐릭터 블루프린트
1. 변수추가.  이름 : RespawnLocation  타입 : Vector
2. EventAnyDamage부분 제일끝에 조건문 추가
   1. Branch - 체크포인트에서 리스폰되는 기능 호출
      1. 조건으로 getHealth() - less Equal 0  - Respawn Player
      2. Branch True일때 미완성인채로 다음꺼 정의부터.
3. 체크포인트에서 리스퐅되는 기능 정의
   1. add custom event   이름은 RespawnPlayer
      1. setActorLocation.   위치를 Respawn Location으로
4. 체크포인트 엑터 만들기
   1. new Blueprint Class - Actor   이름 : Checkpoint
   2. Box Collision 과  Scene 컴포넌트 추가
   3. 씬위 위치는 조금위로 옮기기
   4. 박스에 오버레이 이벤트 추가(2번째 초록색 버튼)
5. 오버렙됐을때 기능
   1. Other - Cast to 2dCharacter - Set Respawn Location 에 Scene의 getWorldLocation지정
   2. 컴파일
6. 미완성된 EventAnyDamage의 Branch로 가서 Respawn Player 호출
7. 체크포인트 레벨에 배치후 테스트 3:10
1번눌렀을때 카메라 흔들거리는거 뒤에 데미지 받기 추가. 
1번 Pressed - ApplyDamage - 연결끊기
   Damaged Actor는 GetPlayerCharacter
   BaseDamage는 1
체크포인트의 Box의 hidden in game 체크해제
실행 : 체크포인트에서 안태어나고 죽은 위치에서 태어남  아!!! 고칠려고 겁나 돌려봤는데 해당 위치를 지나야 세이브포인트가 저장되는구나.

약간 위에서 떨어지도록 수정
캐릭터 - EventBeginPlay 과 SET사이에 SetRaspawnLocation() 추가
   getActorLocation에서 z축으로 10 add한것으로 값 세팅
   안바뀜. 50으로 바꿔도 안바뀜. 
스프라이트
1. Sprites/Objects 새폴더 Checkpoint
2. 리소스 가져오기  Objects의 Campfire
3. 스프라이트 만드는작업 이름은 Campfire1
4. Chekpoint 뷰포트로 가서 PaperFlipbook 컴포넌트 추가 . 박스 하위로 위치.
5. 스프라이트 변경. 크기 4로 변경
테스트 : 다필요없고 그냥 Scene의 위치를 높이 올리니까 거기서 떨어지는데?

>40. How to create a Life System(8:25)
캐릭터
1. 변수추가  Lives  float(나는int). 디폴트값 3
2. 데미지 처리하는 부분
3. Respawn Player 뒤에 막 처리하는데 나는 그뒷부분이 없네.
   1. 최대체력으로 체력을 세팅하고
   2. Playerhud를 가져와서 remove from parent
   3. create Widget
      1. class를 Playerhud WB로 세팅
   4. set player Hud
   5. add to viewport
4. 다시 Respawn Player 앞의 간격 늘리기
5. 원래하던걸 목숨이 1개 이상일때 가능하도록 하기  
   1. branch - get Lives - greater than 1
   2. Branch True로 진행되면 라이프 1깎기   getLives  - decrease - setLives
   3. 변수추가.  변수명 : isdead?    타입 : boolean
   4. life가 1이상인가? 체크하는 branch의 false에서 isdead? 변수값 true로 변환
6. Updateanimation에서 라이프가 없는 상태처리
   1. Branch추가 false가 기존 처리
   2. true에는 죽은 애니메이션 추가   setFlipbook
   3. Sprites폴더에 DeathSmoke폴더 추가. 리소스에서 smoke이미지들 가져오기
   4. paper2d로 만들고 create sprites
   5. create Flipbook.   이름은 Smoke
   6. 그놈으로 위에서 하던 SetFlipbook의 플립북 지정
   7. 그 플립북을 변수로 등록.  이름 : SmokedDeath   Animation변수로 이동
   8. smoke에니메이션의 시간이후에 
      1. SmokedDeath 플립북 드래그 - getTotalDuration - Delay() - SetVisibility.  타겟은 Sprite  - Character Movement드래그 - set Active
7. 레벨로 나가 하늘 지우고 테스트 : 강의에서는 1번으로 피깎다가 3번을 죽어야 연기된다.  나는 한번만 죽는데 연기되고 그것도 연기가 계속 피어오르는채로 적은 공격한다.
   -> lives값이 3이 안되어있었음. 
8. Plaeryhud_WB 에서 life표시
   1. vertical Box 패널 추가. 너비는 원래 표시되던거랑 비슷하게 하고 세로로 길게
   2. 도끼와 코인 출력하던 Horizontal Box를 이 vertical Box하위로
      1. 아래 패딩 10
   3. 코인부분박스 복사해서 life로 매핑. 이미지는 없애기

>41. How to create a Spike System (바닥 가시 2:54)
1. 애니메이션 만들기
   1. Objcts/Strikes
2. 블루프린트 만들기
   1. paperSprite 컴포넌트 추가
   2. Box Collision 컴포넌트 추가
   3. 크기 조정하고
   4. NoCollision 설정

### 카메라


#### 블루프린트
- 함수는 앞에 f가 붙고 파란색임.
- 변수는 빨간색?
- PL에서 if문은 BP에서 branch와 같다.
- Sequence  : if(Branch)는 조건에 따라 둘중 하나만 처리하는것이고,
   시퀀스를 쓰면 두가지 태스크를 순서대로 실행한다.
- 함수 만들기
  자주 사용하는 코드는 묶어서 우클릭 함수로 접기 기능 활용
- 화면에서 그놈의 블루프린트로 빨리 들어오려면 엑터 선택하고 오른쪽위 Outliner에서 Edit Blueprint선택

- 디버깅할때 printString함수
- 노드왼쪽에 있는건 파라미터(입력값)
- 노드오른쪽에 있는건 리턴
- 흰색선은 순서


### AI
https://velog.io/@jiyeon2781/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%94%EC%A7%84-4-%EC%9E%85%EB%AC%B8-6%EC%9E%A5-AI-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0


### 깃헙연동
https://www.unrealengine.com/ko/ue-on-github?sessionInvalidated=true
올리는법
소스폴더 그냥 통째로 올리면됨
깃이그노어는 enrealengine 템플릿 선택

#### 충돌 Collision
[공식](https://docs.unrealengine.com/4.26/ko/InteractiveExperiences/Physics/Collision/Reference/)
Overlap : 이벤트는 작동하고 물리연산 안한다.
Block : 막음
noCollision : 충돌을 검사하지 않겠다.


### 해야될일
1. 시체랑은 충돌 처리 없애기
   https://ansohxxn.github.io/ue4%20lesson%201/ch4-4/
   1. Enemy의 데미지받는부분 체력이 0이하되면 죽음 처리 이후에 Set Collision Enabled
2. 앞에 몬스터가 있어도 절벽만 감지하고있음
3. 몬스터 죽으면 아이템 드랍
   1. https://cafe.naver.com/unrealenginekr