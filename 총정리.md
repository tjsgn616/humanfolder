# 웹

## HTML
- Hyper Text Markup Language
- Markup: 정보의 형식과 구조
- 역사적 배경: 웹에서 서로 다른 페이지 간의 정보를 전달하려고
- 만드는 법: 확장자를 .html(파일 제일 위에 <!DOCTYPE html>로 시작한다.)

### 태그들
<a> anchor: href 속성을 통해서 다른 html 파일로 이동할 수 있다.
<head>: 메타데이터
<body>: 보여지는 본문
<div>: 무색무취의 한줄 다 차지하는 데이터
<span>: 무색무취의 콘텐츠 영역 만큼만 차지함
  - 
<table>: 표
<p>: paragraph(문단)
<img>: 이미지
<h1~h6>: highlight, headline(중요한 제목)

<ul>: unordered list: 순서없는 리스트
<ol>: ordered list: 순서있는 리스트
<li>: list item: 리스트의 아이템
<form>: 제출할 형태
<input>: 제출할 input 내용
<button>: 버튼

<style>: </style>을 만날 때 까지 html이 아닌 css문법으로 해석한다.
<script>: </script>를 만날 때 까지 html이 아닌 script 문법으로 해석한다.
<link>: 다른 문서와 링크되어 그 문서의 내용을 이 문서로 복붙한다.
<nav>: navigation, 현재 웹사이트에서 주요한 지점으로 이동할 수 있는 네비게이션 역할 담당.

- **Sementic**: 의미상의. html자체가 본질이 정보지만 html5에서 더욱 더 그 의미로서의 정보가 강조된다. 의미가 강조된 태그들이 생겨났다.(nav, main, aside, footer)
- <b>와 <strong>의 차이
  - bold는 우리가 보기에 시각적으로만 글자가 두꺼워지는 것
  - strong은 문서에서 의미상으로 중요한 글자임을 나타내는 것이고 시각적으로도 글자가 두꺼워지는 형태이다.

- 왜 Sementic하게 HTML을 만들어야 하는가?
  - 유지 보수의 용이성은 둘째치고 SEO(검색엔진최적화)를 위해서.
  - 검색 엔진 봇들이 돌아다니면서 이 페이지에는 어떤 정보가 있는지 자기 데이터 베이스에 가져가는데, SEO가 잘 안돼있으면 상단에 노출이 잘 안된다.
  - 사용자 편의성 -> 시각 장애인, 색맹 등 정삭적으로 웹페이즈를 볼 수 없는 환경에서 의미상 중요도를 읽어서 내용을 전달해주는데, 시멘틱하지 않으면 무엇이 중요한지 판단 할 수 없다.

- HTML의 요소는 중첩 가능하고, 어떤 태그의 속성이 있는지 없는지 닫히는 태그가 있어야하는지 없는지는 상식적으로 생각하면 해결 가능하다.
  - 예1 img) img자체에 이미지의 원천 src속성을 지정해주면 되기때문에 닫히는 요소가 필요가 없다.
  - 예2 p) 어디서 어디까지가 한 문단인지를 표현 해주어야 하기 때문에 </p>가 필요하다.


## CSS
- Cascading Style Sheet(물처럼 흐르는 스타일 표)
- CSS의 사용 이유: 문서(요소)에 디자인적 서식을 지정해 디자인을 꾸미기 위해서
- CSS 탄생 배경: 원래 HTML이라는 언어만 있었으나 디자인을 태그나 속성으로 하다보니 정보라는 HTML의 본질이 흐려졌고 디자인만 따로 다루는 언어를 새로만드는 것이 좋겠다 해서 만들어 졌다.
- **CSS 사용하는 법:**
  1. 스타일을 지정하려는 태그 안에 속성 값으로 지정하는 '인라인'
  2. HTML 문서 내의 <style> 태그 안에 모아서 기술하는 '내부'
  3. .CSS파일로 별도로 모아서 기술하는 '외부'

- CSS문법: 
    선택자{
        속성 : 값;
        속성 : 값;
        ...
    }
  
  - 어떻게 선택하는가?
    - 그냥 이름: 태그
    - .이름: 클래스
    - #이름: id
    - 이름1>이름2: 이름1의 자식인 이름2
    - 이름1 이름2: 이름1의 자손인 이름2
  
  - **중요한 속성**: color, background-color, height, width, padding, margin, position, display, border
  - 박스모델: 모든 요소는 박스모델이다. 동그랗게 보이든, 선으로 보이든 모두가 박스 모델이다. 개발자 모드로 확인하면 모든 컨텐츠 영역은 파란색이다
    - border를 기준으로 안쪽이 padding, 바깥쪽이 margin이다.
  - position: 선택자가 어디를 기준으로 위치할 것인지를 결정
    - static: 디폴트. 웹의 기본적인 흐름을 따른다. 위에서 아래로 왼쪽에서 오른쪽으로.
    
    - relative: 상대적. static에서 offset 만큼 이동한다.
      - offset: 두 번째 주소를 만들기 위해 기준이 되는 주소에 더해진 값. 예) top : 30px; = 첫번 쨰 주소를 기준으로 top에서부터 30px을 더한 값이 두번째 주소가 된다.
    
    - absolute: 절대적. static이 아닌 부모요소를 기준으로 offset 만큼 이동한다. 그런 부모가 없다면 body를 기준으로 한다.(포토샵의 레이어와 같이 새로운 층으로 해석된다.)
    - fixed: 스크롤과 상관없이 항상 그 위치
    - sticky: 스크롤을 하다가 그위치
  - display
    - inline: 자기 영역만큼만 차지. width, height 속성 없음
    - block: 한줄을 다 차지
    - inline-block: 자기 영역만큼만 차지하는데 width, height 속성을 줄 수 있음.
  - flex
    - 가로축과 주축의 개념
    - 컨테이너와 아이템의 개념
- **bootstrap**
  - twitter에서 만든 오픈소스 css 프레임 워크
  - 적용하는 법
    1. 부트스트랩 소스 다운로드
    2. 디자인 요소 찾기
    3. 해당 클래스로 클래스명 변경


- 단위
  - 절대단위: px
  - 상대단위: em, rem, %, vh, vw

- 미디어 쿼리(mediaQuery)
  - 반응형 페이지: 반응형이라는 것은 하드웨어의 해상도에 반응해서 디자인이 바뀌는 것




## JS
- 웹브라우저에서 유일하게 동작하는 프로그래밍 언어이다.
  - 자바스크립트도 웹브라우저에서만 동작을 하는가? X = Nodejs 환경에서 동작할 수 있다.

- 브라우저의 역사
  - MS의 익스플로러가 망쳐놓은 역사.
  - 춘추전국시대에 등장한 jquery
  - 구글의 크롬이 평정한 역사

- 자바스크립트의 3요소: DOM, BOM, CORE엔진

- **데이터타입**
  - **자바스크립트는 dynamic Typed 언어이기 때문에 데이터타입이 선언시 결정 되는 것이 아니라 값에 의해 결정된다.**
  - 원시타입 5가지: boolean, null, undefined, number, string
  - 이 자료형 외에는 모두 참조형 데이터 타입이다.(데이터 타입을 쪼개 놓은 이유는 비싼 자원인 메모리를 효율적으로 사용하기 위해서이다.)

- 변수(variable)
  - 변수를 사용하는 이유)
    - 1. 값에 이름을 붙여줘서 무슨 의도인지 파악하게 한다.
    - 2. 값을 직접 사용하지 않고 그릇에 담아서 유지보수를 편하게 한다.(하나의 값을 변경시키면 해당 변수를 쓰는 모든 곳이 일괄적으로 변경)
    - var 이름 = 값; / let 이름 = 값;
    - var로 선언한 변수는 덮어쓰기가 가능하다. let으로 선언한 변수는 일단 선언 된 후에는 덮어쓰기가 안된다.

- 배열
  - what: 같은 자료형(자바스크립트에서는 데이터타입이 달라도 된다.) 여러개를 하나로 묶은 것
  - why: 높은 응집도를 위해서(같은 목적을 갖고있는 애들끼리 묶어서 간단하게 하나의 변수로 처리하기 위해)
  - how: 배열 선언(let 배열명 = {값1, 값2, 값3 ...} )

- 연산자 
  - what: 연산을 수행하는 기호
    - 연산 : 식을 계산하여 결과를 얻어내는 과정
    - 예) +,-,*,/,%,++,--,**,&&,||,!=,== 등등
  - why: 연산자를 사용하는 이유
    - 수학의 연산을 어떻게 할 것 인지에 대한 약속으로써 '연산자'를 사용
  - 이항연산자: 2개의 피연산자가 필요한 연산자
  - 단항연산자: 1개의 피연산자가 필요한 연산자 
  - 전위연산자: 변수를 사용하기 전에 연산을 먼저한다.
  - 후위연산자: 변수를 사용하고 연산을 나중에 한다.
    - 예) let a = 4;
          let b = 10;
          let result = ++a + b++ - (++a); 일 때
                      각각 5 + 10 - 6 로 진행이 된다.(이때, a=6 b=11 상태가 된다.)
          let result2 = a++ + ++b;
                        6  + 12 = 18 (이 때, a = 7, b = 12 상태가 된다.) 

- 조건문
  - what: 조건에 따라 컴퓨터가 실행할 문장이 달라지는 것
  - why: 조건에 따라 다른 할 일을 시키기 위해서
  - how: if(조건표현식){
            조건 만족시 실행 할 문장;
            }else if(조건표현식2){
            조건 만족시 실행 할 문장2;
            }else if(조건표현식3){
            ...
            }else{
            위의 조건을 모두 만족하지 않을 때 실행 할 문장들
            }
    - 조건 표현식은 boolean으로 판단 가능해야만 한다.
    - if,else if  대신 if, if 를 사용 시 위의 if를 만족하더라도 다음 if도 검사하기 때문에 if를 여러개 사용할 지 else if를 사용할 지 잘 판단해야 한다.
  
  - 일괄적인 조건문은 switch를 쓰는 것이 좋다.
        switch(조건표현식){
            case 조건1:
                조건1을 만족할 때 실행할 문장들;
                break;
            case 조건2:
                조건2를 만족할 때 실행할 문장들;
                break;
            ...
            default:
                아무것도 만족하지 않을 때 실행할 문장들
        }
    - break는 조건문이나 반복문을 끝내는 역할이다. 없을 시 다음 case로 계속 진행한다.
    - continue는 이번 검사를 끝낸 후 다음 검사로 넘어가게 된다.

- 반복문
  - what: 특정 조건을 만족하는 한 블록의 문장을 반복해서 실행한다.
  - why: 반복적인 코드 입력를 하지 않기 위해
  - while문 / for문
    - while(조건){
        실행문;
        } 
        - do-while문: 조건검사를 하기 전에 실행1번을 먼저 하는 문법
    - for(초기화; 조건; 스텝){
            실행문
        }
        - 향상된 for문: 반복문을 돌 수 있는 객체에 담긴 모든 요소에 대해 실행
        for(데이터타입 요소이름 in/of 이터레이터){
            인자마다 실행할 본문
        }
        - in은 key를 리턴, of는 value를 리턴
        - 
- 함수
  - what: 특정 목적을 가지고 특정 프로세스를 하는 코드들의 묶음(input을 주면 output을 준다.)
  - why: 높은 응집도. 같은 목적을 가진 코드끼리 묶음처리해서 코드의 양을 줄이고 유지보수를 쉽게한다.
  - how: 선언식
          function 함수명(input1, input2, ...){
            함수식 본문;
            return 리턴값;
          }


- 객체
- 이벤트
- 콜백함수
- AJAX