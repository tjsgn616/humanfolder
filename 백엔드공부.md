# 첫페이지 뜨는 원리
  - http://localhost:8080/index.jsp
  - 웹브라우저에서 주소를 치면 DNS(Domain Name Server)가 IP주소를 응답하고, 브라우저는 받은 ip주소의 웹서버에게 요청을 하고 요청을 받은 웹서버가 HTML을 응답한다.
    - ip : 이 세상의 수많은 네트워크 기기들이 가지고있는 고유한 주소
    - localhost : 내컴퓨터. 127.0.0.1
  - 포트번호 : 어떤 서비스에 대한 요청인지 구분. 한개의 컴퓨터에는 웹서버만 실행되는것이 아니라 여러 프로그램들이 실행된다. 그래서 서버의 다른 프로그램과 구분할수 있도록 포트를 사용한다.
  포트는 3가지 범위로 나뉜다.
    - 잘 알려진포트(0~1023) Well-known Ports
        20 = FTP
        22 = SSH
        25 = SMTP
        80 = HTTP. 웹서버의 기본 포트. 즉 HTTP프로토콜일 경우 별도의 포트를 지정하지않으면 80
    - 등록된포트(1024~49151) User Ports
        1434 = MySql
        1521 = Oracle
        8080 = Apache Tomcat. 바꾸고싶으면 server.xml에서 변경
    - 동적및 개인포트 (49152~65535)  Dynamic / Private Ports

웹의 루트 경로 '/'로 접근했을때 보여줄 페이지를 index페이지라고 한다.
- index페이지를 보여주는 조건
  1. index.html, index.jsp가 있는지 찾아본다.
  2. 없으면 index.템플릿을 찾아본다.
  3. 둘다없으면 에러페이지
- 찾을때는 아래의 경로에서 찾는다.
  - classpath:/static
  - classpath:/public
  - classpath:/resources/
  - classpath:/META-INF/resources
- 스프링단에서
  - @Controller,
   @GetMapping("/")
    return 첫페이지파일이름

## 정적자원 vs 동적자원
- 정적자원 : 같은 url을 브라우저에 여러밴 입력하더라도 동일한 결과가 화면에 표시되는 자원
- 동적자원 : 같은 url이라도 시점과 상태에 따라 응답 데이터가 달라지는 자원


### 앱과 웹
웹은 본질이 문서이기 때문에 검색이 가능.
SPA는 AJAX이용하여 하나의 페이지에서 정보만 변경하는것.
Progressive Web Apps = SPA + offline


### 스프링에서 정적 페이지 띄우기
resources/static/index.html 만들고 주소로 치면 된다.
->
1. 컨트롤러
```java
@GetMapping(value = "main.do")

public String openHealthPlannerMain(Model model) {
   return "main";
}
```
1. application.properties 에 spring.mvc.static-path-pattern=/static/** 추가
1. 주소창에 http://localhost:8080/static/main.html
(설정에 static이 없다면 주소창에서 static빼고. 이상하네 상식과 안맞는다.)
스프링부트는 기본으로 statc에서 index.html을 찾는다.  없으면 index 템플릿을 찾는다.
이런 api들을 spring.io에 projects/springboot/learn/해당버전 에서 볼수있다.

### 스프링에서 동적 페이지 띄우기 (타임리프와 컨트롤러 사용.)
@Controller추가. 메소드 만들고
@GetMapping("hello")
public String hello(Model model){
        model.addAttribute( "data", "hello!!!");
        return "hello";
}

localhost:8080/hello라고 유저가 치면, 톰캣이 서블릿에게 묻는다.
@getMapping("hello")  가 받아서 그 메소드가 실행된다.
본문 처리를 하고 return "hello"를 하는데 컨트롤러에서 리턴값으로 문자를 반환하면 뷰 리졸버가 화면을 찾아서 처리한다.
스프링부트 템플릿엔진 기본매핑은 resources/template/뷰이름.html

---


## 웹프로그래밍
- 웹서버가 웹브라우저에 응답으로 전송할 데이터를 생성해주는 프로그램을 작성하는 일.
- 네트워크, HTTP, 파일입출력, HTML, CSS, Javascript, 웹서버, 백엔드언어를 이해하여야 한다.


# 톰캣
- startup.bat가 실행안된다면 자바홈 설정이 안되있는것.

## web.xml
- web application의 설정을 위한 deployment descriptor
- 브라우저가 Java Servlet에 접근할때 WAS에게 필요한 정보를 알려줘야 해당하는 Servlet을 호출할 수 있기때문에 배포할 서블릿이 무엇인지, 해당 서블릿은 어떤 URL에 매핑되는지 알려주는 역할을 한다.


# WAS와 웹서버
WebServer에 Application이라는 말이 들어간것이 WAS.
가장 큰 차이는 컨테이너의 유무.
아파치 톰캣.   웹서버 먼저. WAS 나중 이라 기억하면 편하다.
나누는 이유 : 로드밸런싱. 분산을 통해 빠르고 안정적인 서비스.
              보안. reverse proxy(손님들에게서 서버의 정보를 감춘다. 직접 받아가는것이 아니라 응접실에서 대신 손님들을 맞이하고 요리를 내온다.)
              아파치가 어떤요리를 할지 건네주고, 톰캣이 요리를 한다.
              의사는 접수간호사가 할수있는 일을 할수있지만 쉬운일은 간호사에게 시키는 역할분담.
- 웹서버 : HTTP를 기반으로 클라이언트의 요청에 대한 **정적**인 컨텐츠 제공.
  서버의 특정폴더에 파일들을 넣어두면 사용자의 웹요청에 응답하여 데이터를 보내주는 역할
  - 대표 : **아파치**, NginX, IIS
- WAS : Web Application Server. 웹과 서버 사이에 어플리케이션이란 말이 들어갔지? 단순히 뭘 갖다주는게 아니라 프로그래밍된 뭔가를 한다는 것.
  클라이언트의 요청을 WAS에 보내고 WAS가 처리한 결과인 **동적**인 컨텐츠 제공. DB조회나 다양한 로직처리
  스프링으로 코딩한 웹앱을 war파일로 빌드하면 그안에 .class, jsp, 이미지, css, js파일들이 압축되어있다. 특정폴더에 이 war파일을 넣고 특정 명령어를 실행하면 스프링 서비스가 톰캣으로 돌게된다.
  요즘은 스프링을 통째로 톰캣이 들어있는 jar파일로 빌드해서 배포한다.
  - 대표 : **톰캣**, Jetty, Undertow
  - 왜 was검색하면 죄다 java관련만 나오는가? 정의하기 나름이고 배포구조가 다르기때문에 다른진영에서는 어떤것이 was의 역할이다 라고 구분하지 않기 때문. 쓰는 말이 다르다고 생각하면 된다.
- 같은 사이트를 돌리는 톰캣을 여러개 두는 이유 : 지속성(업데이트시 돌던 서비스가 꺼지지 않도록), reverse proxy 캐싱(자주 찾을만한 리소스를 응접실에 쌓아둠)

### Context Path (컨텍스트 패스)   (**중요**)
웹서버에서 제공하는 다양한 웹 애플리케이션을 구분하기 위해 사용
server.xml에 등록하며, 톰캣입장에서 인식하는 한개의 웹 어플리케이션.
웹애플리케이션 하나당 하나의 컨텍스트를 가져야 한다.
http://아이피주소:포트번호/컨텍스트패스
의 형태로 보이는것 같이 '웹서버'까지 접속했다면 어떤 서비스를 제공받을것인지 알려주는 역할을 한다.
server.xml에 <Context> 태그에 추가된다.
    이클립스는 프로젝트 이름으로 자동 생성해준다.
    path속성이 서블릿을 요청할때 지정할 URL에 기술할 가상의 주소다.
    이클립스에 의해 자동으로 추가된 Context태그덕분에 톰캣이 컨텍스트 패스를 인식할 수 있게 된다.


## bean(빈. 빈즈)
- 개념
JSP페이지에서 소스가 지저분해지지 않고 디자이너와 협업하는것이 쉽도록
화면단에서 자바 객체를 가져다 사용할수있는 기법
- 규칙
1. 모든 멤버변수마다 getter/setter 메소드가 있어야한다.
2. getter에는 매개변수가 없어야한다.
3. setter에는 하나이상의 매개변수가 있어야한다.
4. 생성자는 매개변수가 없어야 한다.
5. 접근제한자의 제약. 멤버변수는  private,    getter/setter는 public,    클래스는 public

- 장점
자바빈을 사용할 경우 <% %>안에 내용이 간결해진다.
디자인부분과 로직부분을 나눔으로써 복잡한 자바코드를 줄이고 프로그램의 재사용성을 증가시킨다.

- 사용
  1. <jsp:useBean id="빈이름" class="자바빈클래스명풀패키지로" scope="사용범위"/>
  2. <jsp:setProperty name="빈이름" property="속성명"  value="설정할값"/>
  3. <jsp:getProperty name="속성명" property="파라미터명"/>
이 액션을 통해 내부적으로 명명규칙에 따른 getter/setter 함수가 호출된다.


## DTO  vs  VO
로직을 가지지 않은 순수한 getter,setter 메소드와 변수만 가진 객체.
- DTO : Data Transfer Object.  데이터 전송 객체
  계층간(layer) 데이터 교환을 위한 자바빈즈라고 생각하면 된다.
  계층이라고 하면 Controller, Business Layer, Persistent, View 등을 말한다.
- VO : Value Objectg.  값 객체
  값을 표현하기 위한 객체이기 때문에 속성값이 달라지면 다른 객체로 본다. 예를들어 색깔 코드.
  setter메소드를 가지면 안되고 생성자를 통해서만 값을 초기화 해야한다.
  그렇기 때문에 디폴트생성자만 있어야하는게 아니다.

# MVC
  - https://velog.io/@ljinsk3/MVC-%ED%8C%A8%ED%84%B4
  - 가장유명한 소프트웨어 디자인 패턴중 하나.
  - Model, View, Controller의 줄임말로써, MVC는 사용자와 상호작용하는 S/W를 디자인함에 있어 세가지 요소로 쪼개어 하는 것을 가르킨다.
  - 왜 쪼개느냐? 입법, 사법, 행정으로 나누듯이 규모가 커지게되면 나눠야 관리가 편하다. 이 기초골격 자체를 미리 짜놓고 제공하는것.
  - 자바의 스프링, php의 라라벨, 파이썬의 장고, 루비의 루비온레일즈, c#의 .net core
  - MVC1패턴과 MVC2패턴이 있다.
  css를 html파일내의 태그안에서 다루느냐, html파일내의 style로 몰아서 다루느냐(mvc1),
  아예 .css로 빼냐(mvc2)의 개념으로 알면된다.
  MVC1은 하나의 jsp파일안에서 요청 비지니스처리, 데이터, 뷰까지 다 처리하는 패턴
  MVC2는 요청을 하나의 서블릿이 받게 된다. 서블릿은 요청을 알맞게 처리한후 결과를JSP로 포워딩
  - 스프링MVC는 스프링 코어 프레임워크에 끼울수있는 스프링의 서브 프로젝트다.
    개발자가 직접적으로 HttpServletRequest/HttpServletResponse 등의 API를 사용할 필요성이 현저하게 줄어든다.
  - 계층(Layer)라는 개념을 알아야 하고 계층간에 정보를 전달해주는 역할을 하는것이 VO또는 DTO가 된다.
    - 레이어를 분리한다는것은 추상화하여 부품갈아끼우듯이 할수있는 것

- [MVC의 역사](https://velog.io/@eddy_song/mvc)
  - 1979년 제록스 팔로 알토 연구소의 트라이브 린스케이지(Trygve Reenskaug)
  - 다이나북팀은 연구자같은 전문가들의 전유물인 컴퓨터를 대중이 직관적으로 사용할수 있어야 한다는 철학에서 사람이 세상을 인식하는 방법과 컴퓨터가 정보를 인식하고 처리하는 방법이 너무 다르기 때문에 이 부분을 잘 분리시켜서 설계하는것의 중요성을 깨달음
  - 좋은 코드를 만들기 위해서,
  어떤 방식으로 코드를 나누고 묶어줘야 할까?
  어떤 방식으로 코드를 추상화해야할까?
  -> '비즈니스 로직'  /  '시각적인 UI' /  둘 사이를 연결해주는 부분


  -용어 설명
  - ### Model
    - 데이터를 전달받아 비지니스 로직을 처리하고 가공하여 저장하는 계층
    - (**중요**)대부분의 설명에서 모델을 DTO같이 설명을 해놔서 이해하기 어려운데 서비스가 모델이라고 생각하면 된다.
    - 서비스는 순수 자바객체(HttpServlet을 상속받을 필요도없는. 마찬가지로 request나 response객체를 매개변수로 받아서는 안된다.)다.
    - 어떤 컨트롤러가 호출하든 상관없다.
    - 클라이언트의 요청이 뭐든 상관없이 필요한 매개변수만 받으면 해당하는 로직을 처리한다.
    - 순수 자바 객체로 구성되었기 때문에 어디서든 재사용이 가능한 클래스파일
    - View(뷰) 또는 Controller(컨트롤러)에 대해 어떤 정보도 알고있으면 안된다.
    - state와 logic의 조합
    
  - ### View
    - 화면에 데이터를 표시하고 클라이언트와 상호작용하는 화면을 담당하는 계층
    - ★★뷰는 데이터를 받으면 화면에 표시해주는 역할만 가진다★★

  - ### Controller
    - view와 model을 연결하는 계층
    - 화면에서 넘어온 매개변수로 어떤 Service를 호출할지 판단하여 호출하는 역할

  
  - MVC패턴의 사용 목적
    - 사용자 인터페이스로부터 비지니스 로직을 분리하여 서로의 영향없이 쉽게 고칠수 있는 어플리케이션을 만들 수 있다. 각 소스의 목적이 명확해지고 유지보수하기가 용이하기 때문.
    - 즉, 본질적인 목표는 '관심사의 분리' 이며 이것은 분업화하여 각자 맡은바에만 집중할 수 있게끔 해준다. 남신경쓰지말고 각자 맡은일만 잘하면 되게끔 하는것.

  - 엄청 헷갈리는 ModelAndView에서의 Model
    - MVC패턴에서의 모델과 개념적(데이터를 처리하고 화면에 첨부시킴)으로는 같은데 물리적으로는 다른놈(MVC에서는 개념인데 Model은 객체임).
    - Controller의 메소드는 특별하게 Model이라는 타입을 파라미터로 지정할 수 있다.
    이를 이용해서 데이터를 담아서 뷰로 전달할 수 있다.
    - 메서드의 파라미터에 Model타입이 지정된 경우에는 스프링은 특별하게 Model타입의 객체를 만들어서 메서드에 주입하게 된다.
    - 스프링 MVC의 Controller는 기본적으로 자바빈 규칙에 맞는 객체는 자동으로 화면에 전달해준다.
    - ModelAndView는 @Controller를 이용하기 전부터 사용했지만, Spirng MVC가 @Controller annotation을     지원하기 시작한 이후로 ModelAndView는 잘사용하지 않는다고 함.

  - 실습
    1. 클래스 만들고 @Controller로 컨트롤러 생성
    2. @GetMapping으로 함수 연결
    3. 함수에서는 Model 파라미터를 받도록 하고
      model.addAttribute(이름, 값); 셋팅해주고
      return "뷰이름";

  - MVC는만능인가?
  이렇게 MVC 규모 자체가 너무 복잡하고 비대해져서, 새 기능을 추가할때마다 의존성을 일일이 해결해야해서 메소드 분석이나 테스트도 어렵게 된다. 이런 형태의 MVC를 Massive ViewController라고 부르는데, 이는 MVC의 한계를 표현한 용어

# MVC모델의 데이터 전송
  1. Servlet / JSP
    모델1방식
     HttpServletRequest / Http|ServletResponse라는 객체를 이용
  1. Spring MVC
    모델2방식 : 로직과 화면을 분리
    직접 Servlet / JSP의 API를 사용할 필요성이 현저하게 줄어듬
    - 사용자의 요구는 프론트컨트롤러인 DispatcherServlet을 통해 처리한다.
    - HandlerMapping이 @RequestMapping 어노테이션을 보고 Request를 처리한 컨트롤러를 찾는다.
    - 이때 View에 전달해야 하는 데이터는 주로 Model이라는 객체에 담아서 전달한다.
    - ViewResolver는 컨트롤러가 반환한 결과를 어떤 View를 통해 처리하는것이 좋을지 해석
    (가장 흔하게 사용하는 설정은 servlet-context.xml에 정의된 InternalResourceViewResolver)
    - View는 응답을 보내야 하는 데이터를 JSP등을 이용해서 생성하고 DispatcherServlet을 통해 전송




---
# 소프트웨어 설계
- 소프트웨어의 복잡성을 낮추는 방법
추상화, 모듈화, 상속, 다형성, 정보은닉, 프레임워크, 디자인패턴, 아키텍쳐, SOLID, 결합도낮추기, 응집도 높이기, 캡슐화

## 객체지향의 4대특성
1. 캡슐화
2. 상속
3. 다형성
4. 추상화


## 객체지향의 5원칙 **SOLID**
1. 단일 책임 원칙 (SRP : Single Responsibility Principle)
  같은 목적을 가진 코드들은 모으고, 다른 목적을 가진 코드들은 흩어라.
  어떠한 클래스를 변경해야 하는 이유는 한가지 뿐이어야 한다.
  심플한 코딩이 된다.
2. 개방-폐쇄 원칙 (OCP : Open-Closed Principle)
  모듈은 확장에 열려있고, 변경에는 닫혀있어야 한다.
  예) 화면으로 출력하나, 프린터로 출력하나, 내컴퓨터에 저장하나, USB에 저장하나 심플한 코드는 조금만 고치면된다.
    JDBC 인터페이스가 오라클, MYSQL, H2 드라이버
3. 리스코프 치환 원칙 (LSP : Liskov Substitution Principle)
  -어떤 인터페이스를 사용하는 프로그램은 그 인터페이스의 구현체(implementation)에 의해 동작이 오락가락하면 안된다.
  말이 어려운데 모든사용자들은 의미를 동일하게 인식하고 있어야 한다는 말이다.
  예를들어서 특정경로를 삭제하는 메소드일때 A구현체는 경로가 디렉토리면 무시하고, B구현체는 경로가 디렉토리여도 통째로 삭제한다.
  이렇게 인터페이스를 구현할때 의미 파악이 달라지면 안된다는 것이다.
  -서브타입은 언제나 자신의 상위타입으로 교체할 수 있어야 한다.
4. 인터페이스 분리 원칙 (ISP : Interface Segregation Principle)
  -사용자가 필요하지 않은 것들에 의존하게 되지 않도록, 인터페이스를 작게 유지하라.
  A가 B에 의존적이면 B가 수정되었을대 A도 다시 컴파일, 배포해야한다.
  -클라이언트는 자신이 사용지 않는 메서드에 의존관계를 맺으면 안된다.
  예) 자전거내비, 해상내비, 항공내비, 도보지도 각각만 받아야지 지도를 받으면 안된다. 인터페이스 분리해야한다.
5. 의존 역전 원칙 (DIP : Dependency Inversion Principle)
  -추상화하는 방향으로 의존하라. 상위 레벨 모듈이 하위 레벨 세부 사항에 의존해서는 안된다.
  -자신보다 변하기 쉬운 것에 의존하지 말아야 한다.
---



-----------------------버전관리-----------------------
# git(깃)
[깃 공식 한글 번역](https://git-scm.com/book/ko/v2)


## 소스트리
Jira, Trello를 제작하고 운영하고있는 Atlassian에서 만든 git의 gui프로그램
- 원격에 아무파일이 없으면 연결안된다. 그래서 readme.md파일을 필수로 만들라고 하는가보다.
- 인증정보를 basic으로하면 비밀번호를 타이핑으로 넣는것이 아니라 토큰 받아서 넣어줘야한다.
[소스트리](https://uxgjs.tistory.com/181)
[기초적인 소스트리 사용](https://coding-groot.tistory.com/135)
[소스트리와 깃헙 연동](https://jojoldu.tistory.com/16)
[충돌 컨플릭트 해결](https://irontech.tistory.com/25)

# github(깃헙)


---

# 폼 데이터 받기
  - 폼은 전달하는애들의 name값들이 있어야하고(dto의 필드명과 일치해야한다.)
    action과 method 정보가 있어야한다.
  - Controller에서는 url을 연결시켜야되는데 method가 post였으면 @PostMapping, get이였으면 @GetMapping
    뒤에 주소넣어주면 받을 준비가된것.
  - DTO작성하기.
  - Contoller에서 해당url을 받았을때 실행할 함수안에 dto를 파라미터로 전달해야지.


## get vs post 방식 차이
- get
  - 근본 : 주소창에 정보들을 담아서 전달.  멱등성
  - 장점 : 조금더 빠르다. 간단하다. 주소창을 복붙하면 같은 데이터를 받아볼 수 있다.(쿼리스트링) 당연히 북마크 된다.
  - 단점 : 보안에 취약하다.
  - 캐시가 가능하고 요청이 브라우저 히스토리에 남는다.
  - GET은 파라미터에 데이터를 담아 보내기 때문에 HTTP 메세지에 body가 없다.
  - ASCII 문자셋만 가능하다.(한글을 쓰면 ASCII로 변환되어 넘어간다)
- post
  - 근본 : 리소스를 생성/변경하기 위해 설계되었다. body길이에 제한이 없다. 멱등하지 않음(전송시마다 응답정보가 다를수 있음)
  - 장점 : 데이터가 숨겨졌기때문에 보안에 좋다.
  - POST요청도 개발자도구나 Fiddler같은 툴로 내용을 확인할수있으니 민감함 데이터는 암호화해야한다.


[쿼리스트링.     Query String]
- get방식으로 요청했을때 URL주소뒤에 입력데이터를 함께 제공하는 방법
- 형태 : URL주소?이름=값&이름2=값2&이름3=값3
    즉 "=" 기호를 중심으로 앞에는 전달되는 파라미터의 이름, 뒷부분은 값이 들어가고
    파라미터들이 여러개일경우 "&" 기호로 연결된다.
- 사용하는이유 : 페이지가 이동하더라도 데이터를 잃지않고 정보교환 가능
- 공백은 +로 변환되고 한글은 %기호와함께 16진수로 변환되어 전달된다.


##### redirect vs forward
- Redirect
  - redial로 외우기
  - 고객에게 다른번호 알려주는 방식. url이 변한다.
  - request, response 객체가 **새롭게 생성**된다. 이전에 요청했던 정보는 사라진다.
  - 뒤로가기 가능
- Forward
  - 자기가 다른 상담원에게 물어봐서 답을 얻고 처리해주는방식. url안변한다.
  - request, response 객체를 **공유**한다. 즉, 내상황(같은말) 또 안 전해줘도된다.
  - 뒤로가기 불가

- 사용법 예
  게시판 글쓰기를 수행할때 둘중 뭘 사용해야할까?
  => Redirect.
  Foward를 쓰게되면 사용자가 실수로 혹은 고의로 새로고침을 하면 요청정보가 살아있기 때문에 같은 제목과 내용의 글이 여러번 등록 될 수 있다.
  get방식으로 화면전환용으로 쓴다.https://kouzie.github.io/spring/Spring-Boot-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/#spring-security
  => 결론
  시스템(세션, DB)에 변화가 생기는 요청의 경우 Redirect
  시스템에 변화가 없는 단순조회는 foward
- [코드](https://nolja98.tistory.com/69)





---
# 자바와 데이터베이스의 연결
## JDBC
  - Java Database Connectivity
  - 자바진영의 데이터베이스 연결 표준 인터페이스. 1997년 탄생
    - 각 db회사들이 API표준에 맞게끔 JDBC 드라이브를 만든다.
    - DriverManager - Connection - Statement - ResultSet
  - 커넥션관리에 대한 중복코드가 계속 발생하는 것에 불편함을 느낌.
    - 설정파일로 연결정보 설정하도록 변경
    - Bean 주입

## MyBatis
    - 한글 공식 사이트 : https://mybatis.org/mybatis-3/ko/dynamic-sql.html
  - 주관심사 : SQL을 소스에서 분리하자.  쿼리를 Java에서 xml로 옮김.
  - 마이바티스의 가장 큰 장점은 매핑구문.
  - SQLSessionFactory Builder 가 Configuartion파일을 읽어서 팩토리가 나온다.
    SQLSessionFactory는 DB의 연결과 SQL 실행에 대한 모든것을 가진 가장 중요한 객체다.
    SqlSessionFactoryBean을 생성해주는 설정을 해주어야 하는데 root-context.xml에
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
      <property name="dataSource" ref="dataSource"></property>
    </bean>
    위와 같이 등록한다.
    Mybatis만 사용하면 SQLSessionFactoryBuilder를 사용하여 SqlSession을 생성한다.
    Mybatis + Spring 연동모듈에서는 SqlSessionFactoryBean가 대신 사용된다.
  - SqlSessionTemplate은 마이바티스 스프링 연동모듈의 핵심
    - SqlSessionTemplate은 SqlSession을 구현하고 코드에서 SqlSession를 대체하는 역할을 한다.
    - SqlSessionTemplate 은 쓰레드에 안전하고 여러개의 DAO나 매퍼에서 공유할수 있다.
  - myBatis의 공통적인 설정을 지정하는 파일은 mybatis-config.xml 파일이다. 없으면 디폴트 설정대로 돌아간다.
    파일을 만들었다면 root-context의 sqlSessionFactory 부분에
    <property name="configLocation" value="classpath:/mybatis-config.xml"></property>
    같이 설정정보를 넘겨줘야 한다.
    https://atoz-develop.tistory.com/entry/MyBatis-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95
    https://mybatis.org/mybatis-3/ko/configuration.html
  - 커넥션연결, prepared statement 세팅, 세션 유지 등의 작업을 대행해준다. 트랜잭션을 잘못써서 서버가 죽는경우 막아줌.
  - 장점
    - 쿼리와 자바 소스가 분리되어 관리가 쉬워진다.
    - **높은 생산성**(Connection, resultSet, Statement, Trasaction따로 개발 안해도됨,  쿼리소스가 ""+ 식으로 하드코딩 안함)
    - 보안적으로 SQL Injection 막아줌.
    - 오라클일 경우 Blob, Clob 치환에 신경안써도됨
    - 디버깅이 쉬워짐
    - 팁
        - 마이바티스는 한가지 자료형밖에 처리못함. 컨트롤러에서 서비스단으로 던지는 객체 개수는 하나여야함.
        여러개를 쓰고싶으면 Map 함수를 사용하여 하나로 뭉쳐서 던져주거나 매퍼로 가기전에 @Param을 쓰고 매퍼에서 ParameterType을 쓰는 방법이 있다.
    - <typeAlias>
    SQL mapper 파일에서 parameterType이나 resultType을 지정할때 긴 이름의 클래스명 대신 짧은 이름의 alias를 사용할 수 있다.

    ## Mapper
      - Mybatis 매핑 파일.xml에 기재된 SQL을 호출하기 위한 **인터페이스**
      - 매퍼를 사용하기 이전 방식은 session.selectOne("userNS.selectUserById", id) 같은 형식이였다. 문자열로 작성하기 때문에 버그가 생길수있고, IDE의 코드 어씨스턴스를 사용못한다.
      - 사용법
        - ★★ .xml파일의 namespace에 인터페이스의 경로를 적어서 인터페이스와 xml을 동기화한다.
        - ★★ 해당 인터페이스의 메소드명과 sqlId를 같게하면 동기화(매핑)된다.
        - ★★ parameterType 에는 "board.dto.BoardDto" 처럼 경로를 넣어준다.
        - # 와 $ 의 차이
          - preparedStatment와 Statement의 차이점이라고 보면 된다.
          - #{}
            - preparedStatement생성. 동적.
            - #{}가 사용된 위치에 ?가 생기며 파싱된다.
            - ?에 파라미터가 바인딩 되는데 자동으로 되는 원리는 다음과 같다.
            카멜케이스 네이밍 규칙에 따른 setter메소드를 호출하여 ? 위치에 해당하는 변수값을 스트링형태로 바인딩(대체)하여 파라미터 형태가 된다.
            - 값을 대입하는 쿼리가 대부분이기 때문에 대부분 이것을 쓴다.
            - 자동으로 ''를 붙여서 수행시켜준다.
            - sql injection을 예방할수있어서 보안측면에서 좋다.
            - #{value}의 값이 달라져도 동일한 쿼리로 인식한다. 컴파일된 쿼리를 그대로 사용.
            - 이름에서 보듯이 Prepared. 미리준비되어있다. 컴파일이 미리 되어있다.
            - 예) userId값이 "master"라면
               WHERE USER_ID = #{userId} 는 파싱되어 WHERE USER_ID = 'master'가 된다.
            - **사용자의 입력을 받는경우, 데이터가 많은 경우 필터링할때 사용**
          - ${}
            - Statement생성. 정적. 
            - 파라미터 값이 그대로 출력된다.
            - 해당컬럼의 자료형에 맞추어 파라미터의 자료형이 변경된다.
            - 쿼리주입을 막을수없어 보안적으로 불리하다. 그러므로 사용자의 입력을 전달할때는 사용하지 않는 편이 낫다.
            - 문자열에 자동으로 ''를 감싸주지 않는다.
            - 값이 바뀌면 새로운 쿼리로 인식하기 때문에 재사용이 불가능하다. 새로 파싱(컴파일)하기 때문에 속도 저하가 발생한다.
            - **자주바뀌지 않거나 사용자의 입력이 아닌 경우 사용. 예를 들어 테이블이나 컬럼명을 파라미터로 전달하고자 할때**
            - 잘못쓴 예
            ORDER BY USER_ID ${sortOrder} 면 ORDER BY USER_ID 'DESC' 형태로 실행이 되어 에러
            - 잘쓴 예
          
          - 정리하자면 #을 쓰면 DB로 ?로된 문장을 전달하고, 쿼리를 실행할때 값이 대응.
          $를 쓰면 자바에서 컴파일할때부터 값이 대응되어 DB에서는 그대로 실행한다.
          이제 동적과 정적이 무슨말인지 이해될거다.


    - null처리
    mybatis관련 설정파일. 따로 안만들었으면 db연결맺는 설정파일로 가서 jdbcTypeForNull 설정
    예)
        <configuration>
            <settings>
                <setting name="jdbcTypeForNull" value="NULL" />
            </settings>
        </configuration>

## ORM
  - ORM(Object Relational Mapping) 객체관계매핑
  - 관계형데이터베이스의 데이터와 JAVA객체를 서로 변환해주는 라이브러리 혹은 기술을 말한다.
  - 목적
    - Back to Basics. 기본에 충실하여 보다 OOP다운 프로그래밍을 하자는데 의의가 있다.
    객체는 객체대로 설계하고, 관계형 데이터베이스는 관계형 데이터베이스대로 설계하고 중간에서 매핑 (**객체와 관계형 데이터베이스간의 불일치를 해결**)
    - ORM을 통해 SQL문을 자동으로 생성하여 불일치를 해결한다.
    즉, ORM을 사용하면 SQL문을 짤 필요없이 객체를 통해 간접적으로 데이터베이스를 조작할 수 있게 된다.
    - 예를들어 팀원이라는 객체에 nickName이라는 속성이 들어오면 쿼리도 다바꿔줘야되고, 다음주에는 team이라는 객체가 내부객체로 들어왔다고 하면 관계형데이터베이스에서는 team의 pk가 들어와야된다. 이런것들때문에 객체지향적 코딩이 불가능하다.  즉 한쪽이 변하면 한쪽이 같이 변해야한다.
  - 핵심
    EntityManager, 영속성 컨텍스트.
    Entity를 관리하다가 flush할때 쿼리가 동적으로 생성된다. 아예 쿼리를 관리하지 않겠다는것.
  - 대표적인 ORM
    JPA(API 표준의 이름), Hibernate(JPA표준대로 만들어진 제품중 가장 유명한것), SpringData의 JPA(한단계더 추상화)
  - 장점
    비지니스로직에 집중(기본적인 쿼리를 자동으로 만들어줌), 유지보수의 편리성(테이블 변경시 JPA의 엔티티만 수정), DBMS에 대한 종속성 하락
  - 단점
    학습이 어려움, 테이블 설계를 잘해야함, 특정데이터베이스의 함수 사용못함, 잘못된 사용을 할 경우 속도 및 일관성 훼손, 복잡한 프로젝트일경우 난이도 증가


## JPA
  - Java Persistence API
    - Persistence Layer는 프로그램의 아키텍처에서 데이터에 영속성을 부여해주는 계층을 말한다.
    - Persistence Framework는 SQL Mapper와 ORM으로 나눌 수 있다.
    - 위에서 순서대로 UI, Service, Domain, Persistence 계층이 있다.
    - javax.persistence 패키지에 정의되어있다.
    - 그럼 persistence는 무엇인가. 영속성. = 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 특성
  - 자바진영의 ORM 기술 표준 API(자바어플리케이션에서 관계형데이터베이스를 사용하는 방식을 정의한 인터페이스)
    - **인터페이스**라는것이 핵심. JPA자체는 사양일뿐 자체적으로는 어떤 작업도 수행하지 않는다.
    - 기존의 EJB에서 제공되던 엔티티 빈을 대체하는 기술. javax와 lombok만 있으면 db와 자바를 매우 간단하게 연결할 수 있다.
  - 대표적인 구현체
    Hibernate, OpenJPA, TomLink Essential 등이 있다.

  - 개발자가 JPA를 사용하면 JPA내부에서 JDBC API를 사용하여 SQL을 호출하여 DB와 통신한다.

---
## 예외처리
- 설명 : 에러는 크게 컴파일 에러와 런타임 에러로 나뉜다.
  발생하게 되면 치명적이여서 복구할수 없는것을 '에러. 오류. Error'라고 한다. 이것은 프로그래밍적으로 막을수가 없다. 즉 시스템레벨에서 생기는 심각한 문제.
  반면에 발생하더라도 개발자가 수습이 가능한것을 '예외. Exception'라고 한다.
  둘다 Throwable 클래스를 상속받는다.
[!예외클래스의구조](../이미지/예외클래스의구조.png)

- 설명2 : 성공하는법이 아니라 실패하지 않는법.
- 문법 :
    try {
      예외가 생길만한문장(실행할 본문)
    }
    catch (캐치할 예외){
       예외 처리
    }
    finally{
         반드시 실행할 문장
    }

- 예외처리의 목적 :
  해당 프로세스를 처리하다가 발생할수 있는 에러(예외)를 사전 예방해서 프로그램이 비정상 종료 되지 않도록 함

- 예외의 종류 :
  1. 체크 예외
    Exception클래스를 상속받음. 의도하지않은 예외.  반드시 예외처리 코드를 작성해줘야한다. 안하면 컴파일에러.
  2. 언체크 예외
    RuntimeException클래스를 상속받음. 의도한 예외. 예외처리를 강제하지 않는다.

- 에러의 종류
  1. 컴파일에러
  문법에러, 오타 같은 프로그램이 실행되기 전에 잡히는 에러

  2. 런타임 - 논리적에러
  문법상 이상없지만 논리적으로 이상하거나 빼먹을 경우 발생. 컴파일은 되나 실행시 에러가 발생.
  나눗셈을 할때0으로 나눈다든지, 순서도를 이상하게 짰다던가, 준비물을 안챙기고 현장에 내보내게 한다든가 등

  2. 런타임 - 시스템에러
  운영체제, 네트워크, 하드웨어, 데이터베이스 등의 문제로 생기는 에러
  개발자가 처리하기 어렵다.


- else if 같이 여러 catch가 있더라도 위에서 실행되면 다음 catch는 실행안된다.
- 모든 catch에 return이 있다면 그 밑으로는 문장이 있더라도 실행안하기 때문에 finally를 쓴다.
- 편리함이 독이되기도 한다.
오류를 분석해서 소프트웨어를 안전하게 짜는것이 아니라 예외로 처리하면서 얼렁뚱땅 지나가게 끔 하는식으로. 진짜 터져야 할곳에서 안터지면 엄청난 문제로 야기될 수 있다.
IDE가 알려주는대로만 생각없이 try catch 자동문장 만드는것. 컴파일 에러는 안나겠지만 예외가 발생했을때 원인을 파악하기 어렵고 처리를 남에게 넘기지도 않고 자기도 하지도않는 민폐.
- e.getMessage(),   e.printStackTrace();


- 예외처리방법
1. 복구 : 문제를 해결해서 정상상태로 되돌림. 불가능한 작업이라면 다르게 작업을 처리하도록 유도
2. 회피 : 처리하지 않고 호출한쪽으로 폭탄돌리기
3. 전환 : 처리할수있는 예외로 변환하여 던짐
- throw : 고의로 예외를 발생시킬때 사용
  예를들어 일정시간동안 일정횟수이상 계속 연결을 시도하는경우.
- throws : 자신에게 발생한 에러를 자신을 호출한놈에게 던짐. 함수정의시 옆에 붙여줘야한다.

---
## 로그 logging
- 기능
    시스템 운영에 대한 기록. 오류에 대한 기록을 남겨 디버깅을 용이하게 함.
    문제가 발생했을때 그 당시의 정보가 필요하기 때문에 기록을 일정한 형태로 남겨둠.
- 자바 기본제공 로거 : java.util.logging.Logger
- 로그레벨
  severe, warning, info, config, fine, finer, finest
- 대표적인 로그 라이브러리 : log4j, logback, slf4j(인터페이스)

#### log4j
- Apache에서 만든 가장 오래된 로깅 프레임워크.
- 2015년에 업데이트 중단 발표
- 3요소 : Logger, Appender, Layout


#### logback
- SLF4J의 구현체. log4j를 기반으로 두고있다.
- log4j개발자가 개발. log4j와 유사하지만 향상된 성능과 필터링 옵션. 설정파일 자동reload 가능.
- logback아키텍처에서 발생하는 문제점을 수정.
- 스프링부트의 기본으로 설정되어있어 별도 라이브러리 추가 필요없음
- resources밑에 logback-spring.yml, logback-spring.xml 순서로 설정을 읽어간다.

#### log4j2
- log4j를 기반으로 두고있다.
- 가장최근에 등장.

#### commons-logging
자카르타 Commons에 포함되어있는 프로젝트들이 로거로 사용하는 API
interface이기 때문에 자체적으로 로깅 기능을 구현하고 있지 않다.

#### slf4j(Simple Logging Facade For Java)
로깅 퍼사드. log4j, logback, commons-logging과 같은 로깅 프레임워크를 위한 **추상화**를 제공해준다.
예를들어 log4j를 사용하다가 log4j2로 로깅프레임워크를 교체하면 많은 코드 수정이 발생하는데 이런점을 막기위해서 slf4j를 사용하고 갈아끼운다.

즉, 결론은 slf4j + log4j2

### 직렬화 serialization
인스턴스의 상태를 그대로 파일에 저장하거나 네트워크로 전송하고 이를 다시 복원하는 방식.
자바에서는 보조스트림을 활용하여 직렬화를 제공한다.
ObjectInputStream, ObjectOutputStream
Serializable 인터페이스

---


# JDK vs JRE
JDK 안에 JRE 안에 JVM이 있는 구조
- JDK
  Java Development Kit(자바 개발도구)
  자바로 애플리케이션을 개발하기 위한 환경 제공
- JRE
  Java Runtime Environment(자바 실행환경)
  자바 애플리케이션을 실행하기 위한 환경 제공
<img src="이미지/JDK와JRE.png" width="50%" height="50%"/>

# JVM
Java Virtual Machine(자바 가상 머신)
자바가 다른언어와 구별되는 가장 큰 특징은 "Write once, run everywhere" (한번 작성하면, 어디서든 실행된다.)
실행되는 OS에서 제공하는 라이브리를 가져오거나 각 OS의 특성에 맞게 다시 개발 안해도된다.
<img src="이미지\JVM내부구조.jpg" width="80%" height="80%"/>
JVM은 OS로부터 메모리를 할당받아 스스로 메모리를 관리하고 


# JAR vs WAR




---
# Annotation 어노테이션
- 자바5부터 등장한 어노테이션된 요소들의 행동으로부터 프로그램의 행위를 추출하여,
프로그램 요소와 메타 태그에 관계된상호 의존적인 코드를 생성해주는 기술
- 쉽게말하면 메타 정보를 생성해준다.
- 유저가 직접 만들수도 있고 비지니스 로직과는 별도로 메타정보들을 명확하고 알아보기 쉽게 표현해 줄 수 있다.



# 요소와 기능 모음
- [로그인 권한에 따라 메뉴 숨기고 나타내기](https://goldenraccoon.tistory.com/entry/%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%97%AC%EB%B6%80%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%A9%94%EB%89%B4-%EC%88%A8%EA%B8%B0%EA%B3%A0-%EB%82%98%ED%83%80%EB%82%B4%EA%B8%B0-SECURITY)

# 디자인패턴 (Design Pattern)
소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 할 수있는 훌륭한 해결책
“바퀴를 다시 발명하지 마라(Don’t reinvent the wheel)”
정리하자면 어떤 문제를 해결하기위해서 역사적으로 가장 정석으로 약속된 설계 방법.

# 팩토리 factory
객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 일을 한다.
디자인패턴의 추상팩토리 패턴이나 팩토리 메소드 패턴과는 다른 개념이다.
단지 오브젝트를 '생성' 하는 쪽과 생성된 오브젝트를 '사용' 하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용한다.
- 추상 팩토리 패턴
인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성
(반대로 new로 인스턴스를 생성하는것은 인터페이스가 아니라 특정 구현을 사용하는 것이다.
  - 왜 사용하나?
    : 나중에 바뀔 수 있는 부분이 생기더라도 소스를 수정하지 않는 유연한 코드를 만들기 위해.
    즉 바뀌는 부분을 찾아내서 바뀌지 않는 부분과 분리시켜야 한다는 원칙
  - 예
    피자의 종류가 치즈냐, 페퍼로니야, 불고기냐에 따라서 if(type.equals("cheese")) pizza = new CheesePizza();
    이런식으로 각기 다른 인스턴스를 생성하는것이 아니고, 뒤는 [여기참조](https://jusungpark.tistory.com/14)

- 팩토리 메소드
객체를 생성하기 위해 클래스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다.
  - 어떨때 사용하나?
    - 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을때
    - 인스턴스를 생성하는 일을 서브클래스로 맡길때

# 리터럴 (literal)
프로그램에서 직접 표현한 값
종류 : 정수, 실수, 문자, 논리, 문자열


---
# lombok(롬복)
- 자바코드의 DTO를 만들때 사용되는 getter/setter, toString등의 코드를 @Data, @Getter, @Setter등의 어노테이션만으로 코드를 자동생성해주는 자바 라이브러리
  - IDE의 자동생성 기능도 있지만 이 역시 반복적이고, 속성이 수정할때마다 메소드들도 수정해줘야했다.
  - 어노테이션으로 인한 순환참조를 유의해야한다.
- 1. 프로젝트에 설치
pom.xml같은 프로젝트에 포함시켜줘야한다.
- 2. 이클립스에 설치(2번까는것처럼 느껴지는 이유). 한번만해주면됨.
롬복은 이클립스 에디터 내에서도 사용되어야하기때문에 STS에 플러그인형태로 설치하는작업이 필요하다. 밑에것만 설치하면 getter/setter등의 함수는 생기지만 이클립스에서 참조하지 못해서 에러표시줄이 뜬다.
롬복 설치파일위 위치를 shell로 열어서 java -jar lombok.jar 실행
STS위치 선택하고 install/Update버튼 클릭.
그러면 .ini파일에 -javaagent:롬복경로\lombok.jar 이런 한줄이 추가된다. 경로에 한글이 있다면 STS실행이 무반응되는 현상이 있다.
어노테이션이 클래스에 안먹히면 .ini파일 확인하고 이클립스 재시작


---

---
# 정리해야될것
EJB :
AOP :


-------------------------아마존 웹서비스-------------------------
# AWS
# ECS # RDS
https://artiiicy.tistory.com/9
- ★★★aws접속 안된다면★★
  1. 내컴퓨터의 outbound 규칙 확인
    2. 서버의 보안그룹의 inbound규칙 확인
    3. RDS - 데이터베이스탭 - 인스턴스 클릭하고 - 수정 버튼 - 연결부분 내려가서 추가구성 - 퍼블릭 엑세스 가능 체크 돼있는지 확인
    4. 호스트네임에 ip주소가 아닌 RDS의 endpoint 지정
- RDS 서비스는 EC2와 동일한 보안 모델을 사용합니다. 가장 일반적인 사용 형식은 동일한 VPC 내에서 어플리케이션 서버로서 운영 중인 EC2 인스턴스에 데이터베이스 서버로서 데이터를 제공하거나, VPC 외부에 있는 DB 어플리케이션 Client에게 접근이 가능하도록 구성하는 것입니다. 적절한 접근 통제를 위하여 VPC 보안 그룹(Security Group)을 활용해야 합니다.
- 보안그룹
보안 그룹은 하나 이상의 인스턴스에 대한 트래픽을 제어하는 가상 방화벽 역할을 한다.
인스턴스를 시작할 때 하나 이상의 보안 그룹을 인스턴스와 연결한다.
연결된 인스턴스와 트래픽을 주고받을 수 있게 하는 규칙을 각 보안 그룹에 추가한다.
언제든지 보안 그룹에 대한 규칙을 수정할 수 있다.
새 규칙은 보안 그룹과 연결된 모든 인스턴스에 자동으로 적용된다.

# VPC 와 서브넷(SUBNET)
- Virtual Private Cloud
- 사용자가 정의한 가상 네트워크로 AWS 리소스를 시작할 수 있다.
-  EC2 인스턴스 하나를 만들기 위해서 사용자가 직접 네트워크 환경을 직접 구축해야한다면 불편하고 복잡할 것이다. 사용자가 직접 네트워크 환경을 설계할 수 있다는 것은 아주 큰 장점이지만, 바로 사용할 수 있는 기본 환경을 제공하는 것도 중요하다. 따라서 AWS에서는 AWS 계정을 생성할 때 리전 별로 기본 VPC를 함께 생성해준다.
- EC2의 네트워크 항목을 보면 EC2인스턴스를 실행할 VPC를 선택하는곳이 있는데 하나의 인스턴스는 반드시 하나의 VPC를 지정해줘야한다.
- VPC만 가지고는 아직 아무것도 할 수 없다. VPC는 다시 한 번 CIDR 블록을 가지는 단위로 나눠진다. 서브넷은 실제로 리소스가 생성되는 물리적인 공간인 가용존Available Zone과 연결된다. VPC가 논리적인 범위를 의미한다면, 서브넷은 VPC 안에서 실제로 리소스가 생성될 수 있는 네트워크라고 생각할 수 있다.
VPC는 N개의 서브넷을 가질 수 있다.
- EC2는 웹 서버가 있다는 점에서 퍼블릭(Public) 상태여야 하며 RDS는 EC2에서만 접근할 수 있는 프라이빗(Private) 상태여야 해요. 외부에서는 EC2에만 접근할 수 있으며 AWS RDS 데이터베이스는 EC2를 거쳤을 때만 이용할 수 있도록.

# IAM
- Identity and Access Management ()자격 증명 기반 정책)
- AWS리소스에 대한 엑세스를 안전하게 제어할수있는 웹 서비스


---


--------------------- # 인코딩 ---------------------
- 문자셋(charset)
하나의 언어권에서 사용하는 언어를 표현하기 위해 그언어권의 모든 문자의 집합
예) KSC5601(EUC-KR)


- 인코딩 (encoding)
문자셋을 컴퓨터가 이해할 수 있는 바이트와 매핑하는 규칙
예를들어 ASCII 코드에서 A,B는 문자셋이고 A는 65, B는 66으로 매핑한것이 인코딩이다. 따라서 문자셋을 어떻게 인코딩(매핑)하느냐에 따라 다양한 결과값이 나올 수 있다.
- 윈도우에 설치한 이클립스 디폴트 : MS949
- 맥에 설치한 이클립스 디폴트 : UTF-8

- 가져온 파일의 문자설정과 이클립스의 문자설정이 다르기 때문이다.
 (리눅스 <-> 윈도우에서 각각 작업한 파일이 os영향을 받아 충돌되서 한글이 깨지는게 아니다. 이클립스의 문자셋을 서로 동일하게 만들어주지 않아서 한글이 깨진다.

- 이클립스의 한글깨짐 확인방법
메모장으로 열어서 한글이 깨지는지 확인을 하고 그 파일을(폴더) 사용자가 정의한 워크스페이스 영역에 복사한 후 이클립스에서 워크스페이스를 추가한다. 이클립스에서 한글이 들어가 있는 자바파일을 열어서 문자가 깨지는지 확인하고 문자가 깨진다면 이클립스 문자설정을 변경한다

- 중앙버튼인 Save as UTF-8을 눌렀다면 한글 깨진 파일이 깨진 상태로 그대로 저장이 되어 아래의 방법으로도 복구할 수 없다
General > Workspace의 Text file encoding을 Default (MS949)에서 Other: UTF-8로 바꾼다.

- 워크스페이스를 만들 때마다 생기는 일로, 다른 컴퓨터가 아닌 기존의 컴퓨터에서 작성한 파일을 워크스페이스 변경으로 이사만 하더라도 빈번히 한글이 깨져 워크스페이스의 인코딩을 UTF-8로 변경시켜야 한다는 것을 기억하자.


---
### 스프링 시큐리티
  [스프링부트 간단한 권한관리 예제](https://dkyou.tistory.com/15)
  [타임리프 스프링부트 회원가입](https://technology-share.tistory.com/20)
  [스프링 권한별로 동적 메뉴구성](https://zgundam.tistory.com/51)
    [타임리프 사용자의 로그인 여부에 따라 작동하기](https://gorokke.tistory.com/170) sec:authorize
    [스프링부트라면 매우 간단](https://ncucu.me/134)thymeleaf security의 authorization.expr를 활용
  Authorization =  허용된 사용자에게만 자원에 대한 접근/수정할 권한을 준다.
  [권한에 따라 들어갈수있는 페이지 제한 정리잘됨](https://to-dy.tistory.com/75)
  [사용자정의 권한 스프링부트 거의 공식](https://www.codejava.net/frameworks/spring-boot/spring-boot-security-role-based-authorization-tutorial)



  [글쓴이만 수정삭제 가능](https://semtax.tistory.com/76)
  HandlerInterceptor 구현
    1. 세션id가져옴
    2. 세션id와 게시글의 저자 비교
    3. 같은경우 접근허용, 같지않으면 권한없다는 메세지 보내고 접근 거부

  [세션 정보]
  페이지를 이동할때마다 계속해서 서버와 연결해야하는 불편함(Stateless상태)을 해결하는 두가지 방법. 세션과 쿠키.
  - 세션
  세션을 구현하기 위해 컨트롤러에서 HttpServletReqeust 받도록 함.
  ```java
  @RequestMapping(value = "/modify", method = RequestMethod.POST)
  public ModelAndView modify(Member member, HttpServletRequest request) {

          HttpSession session = request.getSession();

          Member mem = service.memberModify(member);
          session.setAttribute("member", mem);

          ModelAndView mav = new ModelAndView();
          mav.addObject("memAft", mem);
          mav.setViewName("/member/modifyOk");

          return mav;
  }
  //getSession 함수로 세션을 가져올 수 있다.
  //invalidate 함수로 세션을 끊을 수 있다.
  ```
- 쿠키
Cookie객체를 통해 간단히 만들 수 있다.

---
### 패키지와 폴더의 차이
물리적으로 다른 폴더에 위치하고 있더라도 패키지 이름이 같으면 같은 패키지로 인식하여 접근제한자 없이도 같은 클래스에 있는 함수들 사용할수 있다.


---
좋은 사이트
[안경잡이개발자](https://ndb796.tistory.com/)
[김병국 포트폴리오](https://deaguowl.github.io/)
[삵.io](https://sarc.io/)


---
좋은 프로그램
- 크롬 확장 Talend API

---
## 알림(push notification)
[공식사이트](https://firebase.google.com/docs/cloud-messaging?hl=ko)
http://zeany.net/26
  ### Firebase Cloud Messeging(FCM)
- 서버에서 발생한 이벤트를 특정 클라이언트에게 Event발생 사실을 통지하는 기술
- FCM토큰을 통해 이루어진다는것을 이해해야 한다.
앱을 firebase와 동기화하면 각 기기들의 고유한 Instance Id를 통해 FCM토큰을 발행받는다.
- 구글이 2014년 Firebase를 인수하면서 GCM대신 FCM을 만들었다. 이를통해 안드로이드뿐만 아니라 아이폰, 웹앱 등에서 메시지 전송가능.


<구현 프로세스>
1. 프로젝트에 Firebase추가하는 과정
  1. FCM Token 추출 및 DataBase에 저장
  2. Firebase Console에서 앱 등록 및 동기화
  (
  - AndroidManifest.xml파일의 <manifest>항목의 package속성과 등록할때 패키지이름은 같아야한다.
  - 프로젝트수준의 build.gradle에 의존성 추가,
  앱수준의 build.gradle에 의존성 추가
  - FCM에 등록하고 얻은 services.json이라는 설정파일(apiKey, senderId)을 app디렉토리아래에 복사하고 다시 배포)
2. 프로젝트에 클라우드 메세지를 받을수있는 코드를 추가하고 FCM console에서 메세지 전송 테스트
(이전에 추가된 앱이 디바이스에 설치된 상태여야 한다. 백그라운드 상태여야한다.)
  1. 서버에서 바로보내고싶다면 [콘솔창](https://console.firebase.google.com/?hl=ko)에서 바로 Notification - 메세지보내기
  2. 콘솔창에서 바로가 아니라 코딩을 해야한다면 서버에서 특정 이벤트 발생시 firebase의 cloudstore에 데이터 생성
  (데이터에는 알림을 받는 수신자의 FCM Token이 필요)
  3. onCreate이벤트가 발생할시 Trigger되는 Firebase의 function에서 알림 보내기
  (onCreate이벤트를 사용하면 set, onWrite이벤트를 사용하면 push)


### *.do url에 대하여
당시 자바 웹개발자들에게 단비같은 프레임워크인 스트럿츠가 확장자를 do를 쓰라고 가이드하고있었음.
다른 서블릿과 URL충돌을 막기 위해서.
요즘은 스프링이 강력해서 스프링외의 별도 서블릿 매핑을 할필요가 없지만 예전에는 아니였다.
요즘은 검색과 경량화 두마리 토끼를 잡는 RESTFUL URL이 대세이지만 아직도 .do를 고집하고 있는 개발자들이 상당히 많다.



---
## REST
Representational State Transfer : 자원의 표현에의한 상태 전달
> 자원을 이름으로 구분하여(자원의 표현) 해당자원의 상태(정보)를 주고받는 것
- HTTP창시자중 한사람인 로이필딩이 2000년에 발표한 박사학위논문에서
  기존의 웹아키텍처가 HTTP본래의 우수성을 잘 활용하지 못하기 때문에 그 장점을 최대한 활용할수 있는 아키텍처로 소개
- 구성요소
자원(URI), 행위(HTTP Method), 표현(반환형태)
  : 어떤 유니크한 자원(URI)을
  HTTP Method(행위)로 CRUD 요청을 보내고
  응답은 특정한 형태로 '표현'되는것

- 특징
1. Client, Server : 클라이언트와 서버가 서로 독립적으로 분리되어있어야 한다.
2. Stateless : 요청에 대해 클라이언트의 상태를 서버에 저장하지 않는다.
  //치즈버거 하나주세요. (좀있다가) 아 콜라도 같이 주세요.   이렇게 하면안된다.
3. Cache : 반면에 클라이언트는 서버의 응답을 Cache(임시저장)할 수 있어야 한다. 이를통해 서버의 부하를 낮춘다.
4. 인터페이스 일관성 : 클라이언트와 서버가 독립적으로 개선될 수 있어야 한다.
5. Code on Demand : 특정한 기능을 서버로부터 클라이언트가 전달받아 코드를 실행할 수 있어야 한다.

- 필요한 이유
위의 특징들이 곧 필요한 이유가 된다.
애플리케이션의 분리 및 통합,
다양한 클라이언트, 다양한 디바이스의 등장
이러한 멀티플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍처의 고민

### RESTAPI
REST를 기반으로 만든 API. OpenAPI 또는 마이크로서비스의 대부분은 REST API 제공
화면이 아니라 데이터를 응답하는 API
> 각 요청이 어떤 동작이나 정보를 위한 것인지를 그 요청 자체로 추론이 가능하다.
- 디자인가이드 (**중요**)
1. URI에는 자원만 표현되어 있어야 한다.
2. 행위는 HTTP 메소드(GET, POST, PUT, DELETE)로 전달한다.
3. 서버의 응답 자원은 json, xml, text, rss 등 여러형태로 나타내어질 수 있다.
  
## Restful API
REST의 설계규칙을 잘 지켜서 API를 제공하는 서비스를 RESTFul하다고 말한다.
- 목적
  이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
  성능향상이 아니다. 일관적인 조약을 통한 API의 이해도 및 호환성을 높이는 것



### URI설계패턴
url은 uri의 하위개념이다. 쉽게설명하자면 그것만 보고 찾아갈수있다면 URI, 정확한 위치를 나타내면 URL
URI : Uniform Resource Identifier. 통합자원식별자
  인터넷에서 특정 자원을 식별하는 문자열 시퀀스. 자원을 표현해준다.
  예) https://www.fastcampus.co.kr/resource/sample/1
URL : Uniform Resource Locator
  인터넷상의 특정 리소스가 어디있는지 위치를 알려주기위한 규약
  예) https://www.fastcampus.co.kr/fastcampus.pdf

- URI설계원칙 RFC-3986
1. /를 계층관계를 나타내는데 사용한다.
2. 마지막에는 / 사용하지 않는다.
3. _가 아닌 -를 쓴다.
4. URI는 소문자로만 작성
5. 파일의 확장자는 포함하지 않는다.
6. 프로그래밍 언어에 의존적인 확장자를 사용하지 않는다.  예).do
7. 구현에 의존적인 경로를 사용하지 않는다. 예)servlet/classes/
8. 세션id를 포함하지 않는다.
9. 프로그래밍언어의 메소드명을 이용하지 않는다.
10. 복수형 명사 사용. 특히 컬렉션은
11. 컨트롤러이름으로는 동사나 동사구를 사용한다.
12. 경로중 변하는 부분은 유일한 값으로 대체한다.
13. CRUD 기능을 나타내는것은 URI에 사용하지 않는다.
14. URI 쿼리로 컬렉션 결과에 대해서 필터링 할 수 있다.
15. URI쿼리는 컬렉션의 결과를 페이지로 구분하여 나타내는데 사용한다.

- 예
DELETE /members/1
POST /board/write

# HTTP
- Hyper Text Transfer Protocol.  웹에서 데이터를 주고받는 프로토콜. 즉 무조건 웹에서는 데이터를 주고받기 위해서는 HTTP규약을 따라야 한다는것.
이름에는 하이퍼텍스트가 들어있지만 실제로는 다양한(컴퓨터에서 다룰수있는것은 모두) 전송 할 수 있다.
- HTTP는 TCP를 기반으로한 REST의 특징을 모두 구현하고 있다.
- 가장중요한 특징 : 반드시 클라이언트의 Request, 서버의 Response 형태
    (
    클라이언트 : 요청 메세지 작성, 요청 메세지 전송, 응답대기   -> /*요청을 보내고 일정시간동안 응답이 안오면 요청을 취소한다.*/
    서버 : 요청대기, 요청 메세지 수신, 요청 메세지 해석, 애플리케이션 할당, 애플리케이션 결과 생성, 응답 메세지 송신->
    클라이언트 : 응답메세지 수신, 응답메세지 해석, 데이터 표시 및 처리
    )
- 8개의 메소드
 GET, POST, PUT, DELETE,    HEAD, OPTIONS, TRACE, CONNECT
- HTML은 GET, POST만 지원하고 PUT, DELETE는 지원하지 않는다.
   그러나 스프링은 웹브라우저에 사용되는 GET, POST 방식을 이용해서 PUT, DELETE방식을 사용할 수 있는 기능을 지원해주는데
   그것이 HiddenHttpMethodFilter. 스프링부트 2.1.x이상에는 자동으로 등록되어있다.
- 응답상태코드
1XX : 처리중
2XX : 성공
3XX : 리다이렉트
4XX : 클라이언트 에러(아무리전송해도 에러)
5XX : 서버 에러(재전송시 해결될수 있음)


---
비지니스로직과 관련없는 공통처리를 위해 활용하는 3가지 = 필터, 인터셉터, AOP
![필터영역](../이미지/FILTER영역.png)
![spring mvc request life cycle](../../이미지/리퀘스트생명주기.png)
따라서 요청이 들어오면 Filter → Interceptor → AOP → Interceptor → Controller 순으로 거치게 된다.

#### filter
- 요청과 응답을 거른뒤 정제하는 역할. 스프링 컨텍스트 외부에 존재(요청 자체를 변경시킬수 있는 유일한 영역)
- 서블릿 필터는 DispatcherServlet 이전에 실행
- 보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS방어 등의 요청에 대한 처리로 사용된다.
- 클라이언트로부터 오는 요청과 클라이어언트에게 보내는 응답에 대해 최초/최종 단계의 위치에 존재.
- 이를통해 요청/응답의 정보를 변경하거나 스프링에 의해 데이터가 변환되기 전의 순수한 클라이언트의 요청/응답 값을 확인 할 수 있다.
- 유일하게 ServletRequest, ServletResponse의 객체를 변환할 수 있다. 프링에 의해서 데이터가 변환되기 전의 순수한 Client의 요청/응답 값을 확인할 수 있다.
- 주사용처 : 로깅, 사용자 인증
- 적용방법 : 1. Filter 구현체 클래스 만들고
        2. doFilter 오버라이드
        3. chain.doFiilter(request, response); 아래위로 전처리 후처리
        4. 예를들어 String url = httpServletRequest.getRequestURI();
                BuffredReader br = httpServletRequest.getReader();
                br.lines().forEach(line -> {
                    log.info("url : {}, line : {}", url, line);
                });
[ 필터의 실행메서드 ]
ㆍinit() - 필터 인스턴스 초기화
ㆍdoFilter() - 전/후 처리
ㆍdestroy() - 필터 인스턴스 종료

#### interceptor #### 인터셉터
- 컨트롤러에 들어오는 요청을 해당 컨트롤러가 작업하기 전/후로 가로챈다.
- 로그인 체크, 권한체크, 프로그램 실행시간 계산작업 로그확인 등의 업무처리
- spring-servlet.xml 에 설정후 코드도 적용해야한다.
[인터셉터의 실행메서드]
ㆍpreHandler() - 컨트롤러 메서드가 실행되기 전
ㆍpostHanler() - 컨트롤러 메서드 실행직후 view페이지 렌더링 되기 전
ㆍafterCompletion() - view페이지가 렌더링 되고 난 후

### AOP
(Aspect Oriented Programming)
OOP를 더욱 OOP답게 사용할수 있도록 도와주는 역할.
인터셉터나 filter나 다 AOP의 일종
- 사용이유 : 핵심적인 기능과 부가적인 기능을 분리하고 부가적인 기능의 병렬 적용
  (횡단관심사. Cross-cutting concern)
AOP의 Advice와 HandlerInterceptor의 가장 큰 차이는 파라미터의 차이
Advice의 경우 JoinPoint나 ProceedingJoinPoint 등을 활용해서 호출한다.
반면 HandlerInterceptor는 Filter와 유사하게 HttpServletRequest, HttpServletResponse를 파라미터로 사용

- Aspect(관점) : 부가기능을 분리한 모듈. 어드바이스와 포인트컷의 조합으로 생성
- Advice(부가기능) :  부가기능을 정의한 코드. 5가지 종류
    - @Before: 타겟 메서드가 실행되기 이전에 처리해야될 필요가 있는 부가기능
    - @After: 대상 메서드의 수행 후
    - @After-returning: 대상 메서드의 정상적인 수행 후
    - @After-throwing: 예외발생 후ㆍ
    - @Around: 타겟 메서드의 실행 이전, 이후에 모두 처리해야 될 필요가 있는 부가기능
- JoinPoint : 어드바이스를 적용할 위치(끼워넣을곳).
              메서드, 필드, 객체, 생성자 등이 있지만 스프링AOP는 언제나 메소드 호출이다.
              AspectJ를 쓰면 다양한 지원
    - getArgs() : 메서드 아규먼트를 반환한다.
    - getThis()  :  프록시 객체를 반환한다.
    - getTarget() : 대상 객체를 반환한다.
    - getSignature() : 어드바이즈 또는 메서드의 설명(description)을 반환한다.
    - toString() :  어드바이즈 되는 메서드의 설명을 출력한다
- PointCut : 여러 조인포인트를 하나로 묶은 개념. 타겟의 메소드를 선별하는 `정규표현식`
      execution으로 시작하하고 메소드의 Signature를 비교하는 방법을 주로 이용
- Target(대상) : 비지니스 로직을 수행하는 객체. 어드바이스를 적용할 대상
- Weaving : Advice를 핵심로직코드에 적용한 것. 프록시 객체가 생성된다.
- proxy : 대상객체에 Advice가 적용된 후 생성된 객체


쉽게 정리하자면
AOP클래스에 함수를 만들고 @Around("execution( 로 그 함수가 적용될 위치를 잡아주면된다.



#### 트랜잭션
> 작은 단위작업들을 묶어서 한번에 이루어지는 큰 작업의 단위.
> 예시 : 계좌이체(출금+입금)
  보내는사람의 계좌에서 금액만큼의 잔금이 남아있으면 잔액 = 잔액-보내는금액
  입금받는사람의 계좌에서 잔액 = 잔액 + 받는금액
  그런데, 보내는사람의 자동이체로 인해서 돈을 보낸다고 적을때는 잔액이 있었는데 보내는시점에는 돈이 없을수있음.
  보내고 받는 사이에 1초가 걸리는데 그 1초사이에 서버가 다운돼서, 인터넷이 끊겨서  
  보내는사람의 계좌에서는 돈이 빠져나갔는데 받는 사람은 못받는 일이 일어나서는 안된다.
  또는 보내는사람은 돈이 빠져나갔는데 받는사람의 계좌가 갑자기 정지되면 돈이 증발됨.
  그래서, 받는사람의 계좌에 입금이 정상적으로 이루어졌을경우에만 계좌이체의 처리가 완료되게 하는것.
  즉, 트랜잭션으로 묶인 작업중 하나라도 실패하면 이전에 성공했던것도 롤백시키게 묶음처리하는 것.
- ACID원칙
Atomicity(원자성) : 하나의 트랜잭션은 모두 하나의 단위로 처리되어야 한다. 트랙잭션안의 하나가 실패하면 모두다 롤백
Consistency(일관성) : 트랜잭션으로 처리가 된 데이터와 일반 데이터 사이에는 전혀 차이가 없어야 한다.
Isolation(격리) : 트랜잭션 처리 도중에 외부의 간섭이 없어야 한다.
Durability(영속성) : 성공적으로 처리되면 그 결과는 영속성으로 보관되어야 한다.
- 정규화와의 관계
  정규화가 잘되어있으면 트랜잭션이 많이 일어나지 않는다.
  테이블은 점점 더 순수한 형태가 되어가기 때문.
  반면에 가져오는 입장은 점점 더 불편해진다.
- 설정
1. Transaction Manager 의존성 추가.
2. root-context.xml에서는 Namespaces탭에서 tx체크

---
## 람다식 (Lambda expression)
자바8에서 도입된 함수형 프로그래밍기법
객체지향에서의 메소드는 side effect가 발생하기 때문에 순수함수를 사용하여 외부에 영향을 주지 않기 위한 방식. 외부자료를 사용하지 않기 때문에 여러자료가 동시에 수행되는 병렬처리가 가능하다.
- 장점 : 소스가 간단해짐
- 단점 : 가독성이 떨어짐

<문법>
반환타입과 함수명을 제거하고 -> 를 중괄호 앞에 추가한다.
매개변수가 하나인경우 자료형과 괄호 생략가능
본문이 한문장인경우 중괄호 생략가능
실행문이 한문장의 반환문인 경우엔 return과 중괄호를 모두 생략
```JAVA
int max(int a, int b){
  return a>b? a : b;
}
를 아래와 같이 바꾼것
(a, b) -> a > b ? a : b

```

## 스트림
별로 안중요. 고급영역
- 개념
  - 다양한 데이터 소스를 표준화된 방법으로 다루기 위한 것. java8에서 도입되었다.
  - 데이터의 흐름.
  - 람다를 활용할 수 있는 기술중 하나
- 사용목적
  - 배열이나 컬렉션에 여러 함수들을 조합해서 원하는 결과를 가공한다.
  - 기능을 구현하지 않고 선언형으로 컬렉션 데이터를 처리
  - 즉, 여러줄로 작성하던 반복문, 조건문을 한줄로 멋지게 만들 수 있다.
  - 내부반복자를 사용하기 때문에 병렬처리가 쉽다.
- 사용방법
  1. 스트림 생성
    스트림은 배열 또는 컬렉션 인스턴스를 이용하여 생성한다.
    - 배열스트림 : Arrays.stream(배열명)
    - 컬렉션스트림 : 컬렉션인스턴스.stream();
    - 빌더스트림 : Stream.builder()
        ```java
        Stream<String> builderStream = 
          Stream.<String>builder()
            .add("Eric").add("Elena").add("Java")
            .build(); // [Eric, Elena, Java]
        ```
    - 제너레이터 스트림 : Stream.generate()
        ```java
        Stream<String> generatedStream = 
          Stream.generate(() -> "gen").limit(5); // [el, el, el, el, el]
        ```
    - 이터레이터 스트림 : Stream.iterate()
        ```java
        Stream<Integer> iteratedStream = 
          Stream.iterate(30, n -> n + 2).limit(5); // [30, 32, 34, 36, 38]
        ```
    - Empty 스트림
    - 기본타입 스트림
    - 문자열 스트림
    - 파일 스트림
    - 스트림 연결
  2. 중간가공 : Filtering, Mapping, Sorting, Iterating
  3. 최종연산  : Calculating, Reduction, Collecting, Matching, Iterating
Stream<T>
- 예제
```java
public List<Member> findAdultAsName(List<Member> members, int count) {
  return members.stream()    // 멤버 리스트에서 스트림을 얻는다.
  .filter(member -> member.isAdult())    // 중간 연산
  .limit(count)    // 중간 연산
  .map(Member::getName)    // 중간 연산
  .collect(Collectors.toList());    // 최종 연산, 스트림을 원하는 컬렉션 자료구조로 변경한다.
  }

```



## 쓰레드 thread
- [참고](https://velog.io/@khsb2012/java-study-week10)
- 프로그램 : 어떤 작업을 위해 실행할 수 있는 파일
- 프로세스 : 실행되고 있는 프로그램.   실행되기 위해서는 메모리에 올라와야 한다. 프로세스는 운영체제로부터 자원을 할당받는다. 1개의 프로세스는 최소 1개의 스레드를 가지고있다.
  예) 크롬을 켜서 유튜브를 보고있는동시에 마우스를 움직이는 동시에 파일은 다운받아지고있다.
  예) 햄버거를 시키면 그릴에서 고기굽고, 음료수는 기계가, 감자튀김은 튀김기
- 쓰레드 : 하나의 프로세스내에서 돌아가는 병행적인 메소드
  쓰레드는 프로세스내에서 Stack영역만 따로 할당받고 Code, Data, Heap영역은 공유한다.  즉, 프로세스내의 여러자원들을 공유하면서 실행된다.
- 모든 자바어플리케이션은 Main Thread가 main()메소드를 실행하면서 시작한다.
- 멀티 쓰레드의 장점 : 시스템자원의 효율성 증대, 처리량 증가, 응답시간 단축, 통신의 부담 감소
- 멀티 쓰레드의 단점 : 주의깊은 설계, 까다로운 디버깅, 동기화문제, 하나의 쓰레드가 잘못되어도 프로그램이 멈춤
- 멀티 프로세스 대신 멀티쓰레드를 사용하는 이유
  위에서 말한 쓰레드의 장점.
- 멀티쓰레드의 역사(별로 안중요)
  CPU의 역사와 더불어 이해하면 좋다. 다른실행 다 죽고 기다려야하니까 지금 돌아가고있는, 얼마나 됐는지 뭐 이런게 안됐다.
  워키토키 무전기같은.
  그래서 좋은UX를 위해서 멀티 쓰레드가 나오게 됐다.OS는 컨텍스트 스위칭 때문에 과부하가 발생했다.

  무어의 법칙으로 CPU의 연산속도는 계속 증가하다가 한계에 부딛힘. 열때문에.
  멀티쓰레딩을 안하면 하드웨어 성능이 아무리 좋아도 CPU사용량이 올라간다. 게임업계에서 업데이트(값변경), 렌더(그래픽그리기) 2개로 분리하기 시작했다.
  플레이스테이션3 는 CPU구조가 달라서 저 구조로는 안됐다. PS3가 인기가 많고 오래가기 시작했고 쓰레드가 많아졌을때는 어떻게 할까 생각하면 새로운 쓰레드 구조가 필요했다.
  수천개의 객체들이 한 화면에 있지만 거의 비슷한 일들을 하는구나.
  배리어락의 등장. 코어가 8개. 객체가 800개면 코어마다 100개씩 던져주기. 모든코어의 업데이트가 끝날때까지 기다리기.
  이런방식은 숫자가 많아져도 사람이 추적할수 있는 방식이다.



- **생성방법 2가지**
  1. Thread상속  (java.lang.Thread)
  2. Runnable 인터페이스를 구현
  하지만 Thread를 상속받으면 다른 클래스를 상속받을수 없기 때문에 Runnable 인터페이스를 구현하는 방법이 일반적이다. 둘다 run메소드를 오버라이딩 해줘야한다.
- 대표적인 메소드
  sleep, start, join, run 이 있다.
  호출시 실행하는 메소드는 **start**해주지만 쓰레드가 실제 돌아갈때는 오버라이드하는 run이 돌아간다.
  run을 통해 실행시키면 stack으로 쌓여서 병행처리가 안된다. 해당메소드가 종료되어야 다른 스레드가 실행된다.
  start를 통해 실행해야 정상적인 병행처리가 된다.
  쓰레드를 start하면 바로 실행하는것이 아니라 실행대기상태에 있따가 OS의 스케쥴러가 작성한 스케줄에 의해 순서대로 자기 차례에 실행되는 구조다.
- 쓰레드의 상태 6가지. getState()를 하면 알 수 있다.
  - NEW : 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태
  - RUNNABLE : 실행 중 또는 실행 가능한 상태
  - BLOCKED : 동기화블럭에 의해서 일시정지된 상태(lock이 풀릴 때까지 기다리는 상태)
  - WAITING : 쓰레드의 작업이 종료되지는 않았지만 실행 가능하지 않은 일시정지 상태
  - TIMED_WAITING : 일시정지 시간이 지정된 경우를 말함
  - TERMINATED : 쓰레드의 작업이 종료된 상태
- 쓰레드의 메서드
  - static void sleep(long millis) : 지정된 시간(밀리세컨드, or 나노세컨드)동안 쓰레드를 일시정지시키다. 지정한 시간이 지나고 나면, 자동적으로 다시 실행대기 상태가 된다.
  - void join(), void join(long millis)  : 지정된 시간동안 쓰레드가 실행되도록 한다. join()을 호출한 쓰레드는 그동안 일시정지 상태가 된다. 지정된 시간이 지나거나 작업이 종료되면 join()을 호출한 쓰레드로 다시 돌아와 실행을 계속한다.
  - void interrupt() : sleep()이나 join()에 의해 일시정지 상태인 쓰레드를 깨워서 실행대기 상태로 만든다. 해당 쓰레드에서는 InterruptedException이 발생함으로써 일시정지 상태를 벗어나게 된다.
  - static void yield() : 실행 중에 자신에게 주어진 실행시간을 다른 쓰레드에게 양보하고 자신은 실행대기 상태가 된다.
  - resume(), stop(), suspend()는 쓰레드를 교착상태(dead-lock)로 만들기 쉽기 때문에 deprecated되었다.
- 쓰레드의 종료
    쓰레드는 자신의 run메소드가 모두 실행되면 자동적으로 종료된다.
    그런데 run메소드의 끝까지 가기전에 '즉시 종료' 해야한다면 boolean으로 된 플래그를 사용하거나 interrupt()메소드를 이용하는 방법이 있다.
- void interrupt() : 
    쓰레드에게 작업을 멈추라고 요청한다. InterruptedException 예외를 발생 시킨다. 주의해야할점은 interrupt메소드를 이용하기위해서는 종료시키고 싶은 메소드가 일시정지상태일때 정지된다는것이다. sleep()이나 join()에 의해 일시정지 상태인 쓰레드를 깨워서 실행 대기상태로 만든다.
    쓰레드의 interrupted 상태를 false에서 true로 변경한다.
- static boolean interrupted() : 
    sleep()이나 join()에 의해 일시정지 상태인 쓰레드를 깨워서 실행 대기상태로 만든다.

- 예제
```java
import java.text.SimpleDateFormat;
import java.util.Date;

public class ThreadTest {

    public static void main(String[] args) {
        Runnable d = new CheckThread("손흥민1");
        Runnable d1 = new CheckThread("이강인2");
        Runnable d2 = new CheckThread("황의조3");
        Runnable d3 = new CheckThread("황희찬4");

        Thread thread = new Thread(d);
        Thread thread1 = new Thread(d1);
        Thread thread2 = new Thread(d2);
        Thread thread3 = new Thread(d3);

        thread.start();
        thread1.start();
        thread2.start();
        thread3.start();

    }

}

class CheckThread implements Runnable{

    String name;

    CheckThread(String name){
        this.name = name;
    }

    @Override
    public void run() {
        try{

            for(int i=0;i<5;i++){
                System.out.println(name);
                Thread.sleep(1000);
            }

        }catch (Exception e){
            System.out.println(e.toString());
        }

        System.out.println("쓰레드 종료 : "+ name);
    }
}
```

: IllegalThreadStateException 에러
=> 하나의 Thread객체에 start()를 두번이상 호출할경우 발생한다.
기존에 생성된 쓰레드를 종료시키고 새로운 인스턴스를 만들어서 붙도록 하면된다.
:java.lang.InterruptedException: sleep interrupted
=> 일시 정지 상태에서 주어진 시간이 되기전에 interrupt() 메소드가 호출되면 InterruptedException이 발생하기 때문에 예외 처리가 필요하다.
interrupt함수는 종료시키는것이 아니라 예외를 발생시키는 함수. 정상종료의 표준이다.
**유의할점은 즉시 예외가 발생하는것이 아니라 미래에 일시정지상태가 됐을때 발생한다는점이다.**
예를 들어 5초타이머에 3초세고 interrupt()가 호출되었으면
2초셀때 sleep interrupted
1초셀때 sleep interrupted
가 발생한다.
-> interrupt(); 로 잘 안되는부분이 있으면 return;  으로 바꿔보기.

: java.lang.InterruptedException: sleep interrupted 에러
=> 쓰레드를 외부에서 인터럽트 시켜서 interrupted=true일때 sleep명령어를 받은것
해결법 : try안에 sleep넣고 catch에 스레드 종료 유발

: 정확히 동시에 실행하는법
https://stackoverflow.com/questions/3376586/how-to-start-two-threads-at-exactly-the-same-time

## 단위테스트 ## JUNIT
https://mangkyu.tistory.com/143
- 단위테스트(Unit Test) : 하나의 모듈(기능, 메소드)를 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트
'어떤 기능이 실행되면 어떤 결과가 나온다' 정도로 테스트를 진행한다.
- 통합테스트(Integration Test) : 모듈을 통합하기 위에 그전에 모듈간의 호환성을 확인하기 위해 수행되는 테스트
독립적인 테스트가 아니라 서로의 관계속에서 이상없는지 테스트
- TDD(Test-Driven Development, 테스트주도개발) 에서 얘기하는 테스트는 당연히 단위테스트다.
- 독립적으로 테스트를 하기 위해서는 다른 객체 대신에 다른 객체를 임시로 주입해야 하는데 그것을 stub이라고 한다.
- 좋은 테스트의 5가지 규칙 FIRST
1. Fast : 빠르게 동작하여 자주 돌릴수 있어야함
2. Independent : 독립적이여서 서로 의존해서는 안된다.
3. Repeatable : 어떤 환경에서도 반복가능해야
4. Self-Validating : 눈으로 보는게 아니라 자체적으로 boolean값을 리턴하도록
5. Timely : 실제코드를 구현하기 직전에 구현하는것이 적시.
- 테스트 라이브러리의 대표주자.
    - JUnit5 : 자바 단위테스트를 위한 프레임워크
    - AssertJ : 자바테스트를 도와주는 다양한 문법 지원
    - Mockito : 개발자가 동작을 직접 제어할 수 있는 가짜 객체를 지원하는 테스트 프레임워크
        스프링으로 개발할때는 여러객체들간의 의존성이 존재해서 단위테스트 작성을 어렵게 하는데 이를 위해 가짜 객체를 주입시켜주는 Mockito라이브러리 활용.
- **given, when, then 패턴**
    준비, 실행, 검증으로 나눠서 처리하는 패턴.  //주석으로 영역을 나눠서
- 자바버전마다 junit 호환버전이 다르다. jdk16은 4,5자동포함되어서 따로 라이브러리 갖고올필요없다.
- 문법
1. @Test : 해당 메소드가 단위 테스트임을 명시하는 어노테이션.
JUnit은 '테스트 패키지' 하위의 @Test 어노테이션이 붙은 메소드를 단위테스트로 인식하여 실행시킨다.
    이상태로 실행하면 함수이름이 default로 지정되는데, @DisplayName 어노테이션을 사용하여 일기좋은 다른이름을 부여할 수 있다.
2. return이 void여야 한다.
3. assert로 시작하는 함수로 검증

### 학습 테스트
>자신이 만들지 않은것을 사용하기 위해 기능을 테스트하면서 사용방법을 익히는 목적을 가진 테스트. 기능검증이 목적이 아니다.

### 커넥션풀(DBCP)
- WAS가 데이터베이스와의 연결(커넥션)을 미리 만들어서 POOL에 저장해두고 있다가, 클라이언트의 요청이 오면 빌려주고 처리가 끝나면 다시 반납받는 기법
- 사용이유 : 없을때를 생각해보면 쉽다.
  기존의 JSP프로젝트에서 했던 코드 생각해보자.
  ```java
    Connection conn = null;
    PreparedStatement  pstmt = null;
    ResultSet rs = null;

    try {
        sql = "SELECT * FROM T_BOARD"

        // 1. 드라이버 연결 DB 커넥션 객체를 얻음
        connection = DriverManager.getConnection(DBURL, DBUSER, DBPASSWORD);

        // 2. 쿼리 수행을 위한 PreparedStatement 객체 생성
        pstmt = conn.createStatement();

        // 3. executeQuery: 쿼리 실행 후
        // ResultSet: DB 레코드 ResultSet에 객체에 담김
        rs = pstmt.executeQuery(sql);
        } catch (Exception e) {
        } finally {
            conn.close();
            pstmt.close();
            rs.close();
        }
    }

  ```
   한명의 접속자가 게시판을 확인하고, 글을쓰고, 자기가 쓴 게시물을 수정한다면? 그때마다 DB접속이 일어난다.  사용자가 1000명이라면?
   요청마다 드라이버를 로드하고, 커넥션 객체를 생성하고, 연결하고, 종료하는것은 매우 비효율적이다.
- 서버는 동시에 사용할 수 있는 사람의 수의 한계가 있다. 일반적인 커넥션을 이용하면 동시접속자수를 벗어나면 에러나 예외가 발생하게 된다.
커넥션이 있다면 남아있는 커넥션이 없을 경우 대기상태로 전환시키고 순서대로 부여해줄수 있다.
- 가장유명한 제품. 커넥션풀이 HikariCP
2012년경에 개발된 매우 빠르고 안정적인 JDBC Connection Pool
- 장점만 있을까?
단점은 WAS의 메모리 손실.


##### emptyList vs new List()
List<BoardDTO> boardList = Collections.emptyList();
List<BoardDTO> boardList2 = new ArrayList<BoardDTO>();
해쉬로 비교해도, equals로 비교해도 같다. 다만 emptyList는 요소를 바꿀수없다. 리스트 전체 참조만 바꿀수있다.


##### 스웨거 Swagger
https://velog.io/@banjjoknim/Swagger
https://bcp0109.tistory.com/326


#### 에러 로그(Stack trace) 보는법, 읽는법


### CGI
Common Gateway Interface
웹사이트에서 동적 페이지를 만드는 가장 흔하고 간단한 방법
또 하나의 혁명이었다.


## 서버
[생활코딩WEB2 서버]https://www.youtube.com/playlist?list=PLuHgQVnccGMCI75J-rC8yZSVGZq3gYsFp
- #### host
인터넷에 연결된 컴퓨터(통신기기) 한대


- #### ip
host끼리 연결하기 위해서는 주소가 필요하다. 인류는 IP주소를 쓰기로했다.
이것을 통해 n:n 연결이 가능하게 되었다.
하나의 ip주소에는 여러대의 통신기기(host)들이 연결될수있다.
4개의 0~255까지의 숫자를 이용한다. 약 42억개의 경우의수가 존재할 수 있다.
ipv4 -> ipv6로 전환중이다.
부족한 ipv4(현재)주소로 인류가 사용하기위해서 내부망을 쓴다.
고정ip 2개정도받고 포트로 내부ip로 재할당.
만약 학원컴퓨터가 93.194.216.34:100   선생님   101 : 환석,   102 : 유자
  192.168.0.n
93.194.216.34 같은 아이피 주소는 사람이 기억하기가 너무 어려운 문제가 있다.

DNS는 그것을 해결한다.

- #### DNS
Domain Name System
핵심은 DNS 서버.
수많은 ip주소의 도메인 이름이 매핑되어있다.
우리가 www.icann.org 를 치면 도메인서버가 192.0.43.7:80(매핑된 ip주소:브라우저를 통해요청했으니80포트) 으로 접속해서 그 서버가 반환하는 첫페이지를 다시 우리에게 보여주는 것이다. index.js,   index.jsp 이런 화면을 리턴하게 된다.
이름을 붙인다는 것은 위대한일

- #####  hosts
모든운영체제에는 hosts라는 파일이 있다.
location in the file system 검색해보면 운영체제마다 위치를 알수있다.
윈도우는 $SystemRoot%\System32\drivers\etc\hosts
관리자모드로 열어서 주석아닌곳에
52.231.11.152  web1.com
같은 형태로 적어주면 당연히 실제 도메인네임이 생기는건 아니지만(소유자가 되는것은 아니지만) 이 컴퓨터 안에서는 우선권이 주어진다.

- #### 해킹의 위험 경험해보기
hosts파일을 바꿔서 URL을 쳤을때 매핑되는 ip주소를 다른곳으로 바꾸게 되면 악의적인 사이트로 연결되게 된다.
화면 디자인을 같게 만들어놓으면 깜빡 속는다.
https 로 접속하게 만들어놨으면 이런 변조를 막을수 있다.

- dns이전의 세상
dns가 탄생하게된 배경을 자세히 알면 dns에 대해 훨씬 더 알수있다.
dns를 쓰면 서버의 실제 주소는 유지하면서 이름만 바꿀수있는 유연함을 가질수 있다.
이런것을 하기위해서는 신뢰할수있는 누군가가 있어야 한다.
Stanford Research Institute라는 단체가 그역할을 했다. 영업시간에 전화로 이곳에 요청을 하고 직원이 hosts파일을 갱신해줬다.
전세계의 컴퓨터들이 저 hosts파일을 받으면 수많은 ip와 name의 텍스트가 있었다.
이것만으로도 행복했지만 역시 사람의 욕심은 끝이 없다.
문제 : 추가되기전까지는 이용불가, 반영되기까지 많은 시간과 비용, 하나의 컴퓨터에 모든 정보가 담김. 단체에서는 갱신되었지만 내가 내컴퓨터에 안바꾸면 안바뀜.
그래서 인터넷의 신 Jon Postel, PaUL Mockapetris 에 의해서 DNS가 탄생되었다.


인터넷에 연결하는 순간 DNS Server의 ip가 자동으로 세팅된다. 이작업이 **DHCP**
브라우저에서 url을 입력하면 먼저
내컴퓨터에서 hosts파일을 찾아서 찾으려는 이름의 url과 매핑된 ip가 있는지 찾는다.
없으면 DNS Server에서 ip를 찾는다.

- public dns
어떻게 DNS서버의 ip에 접근할수있었을까?
내가 가입한 통신사(ISP) 들이 내가 도메인을 요청했을때 DNS의IP를 자동으로 세팅해주는 매커니즘을 갖고있기 때문이다.
그럼 통신사가 내가 접속하려는 사이트가 어딘지 당연히 알게 되지.
이미 가진 지식으로 그 문제를 해결할 수 있다.
public dns server  검색하면 여러개를 볼 수 있다.
구글에서 만든건 8.8.8.8 또는 8.8.4.4
내컴퓨터의 network 세팅의 dns를 저걸로 세팅하면 저기로 물어보는것이다.
내가 그 회사를 믿는다면 또는 성능이 좋다면 그걸 쓰는것이다.
2018년에 아시아태평양지역에 1.1.1.1 을 제공하는 단체의 서비스도 생겼다. 속도와 프라이버시가 매우 빠르다.
제이판 - 네트워크와 공유 - Connections - Ethernet - Properties - IP4 - 속성 - 자동으로 돼있는것의 dns부분을 바꿔주면 된다.


이제부터는 인터넷의 사용자가 아니라 생산자가 된다면 알아야 하는 내용이다.
DNS서버는 기억하는것과 알려주는것의 역할을 한다.
전세계에 수많은 DNS서버가 세계 군데군데 분산되어있는데
제일 뒤의 도메인에는 .이 생략되어있다.
예를들어 blog.example.com.    쳐보면 이상없는것을 알 수 있다.
![도메인이름](../이미지/도메인이름.PNG)
저 각각의 부분들을 담당하는 각각의 서버들이 있다.
오른쪽의 더 큰 레벨을 담당하는 서버는 그 한단계 하위레벨의 서버들의 목록과 IP주소를 알고있어야 한다.
이것을 연쇄적으로 물어보기 위해서는 모든컴퓨터가 ROOT컴퓨터의 IP주소는 알고있어야 한다.
거기 접속하게 되면 com을 담당하는 네임서버의 아이피를 알려줄게.
이런식으로 전달전달한다.

- 도메인 이름 얻기
https://www.youtube.com/watch?v=hfj0IGgKAgU&list=PLuHgQVnccGMCI75J-rC8yZSVGZq3gYsFp&index=9
위에서 본 제일 상위인 Root name Server들은  ICANN 이라고 하는 비영리 단체가 관리한다.
a.root-server.net 이런식의 컴퓨터가 전세계에 a부터 m까지 13개가 흩어져있다.
그리고 그 각각이 또 여러개로 쪼개졌다고 하는데 잘 이해안간다.
이제 그 밑에는 Registry라고 하는 등록소들이 있다.  .net, .com,  .co.kr 과같은 top레벨 도메인을 관리한다.
Registrant(등록자)는 Registrar(등록대행자)에게 대행처리를 부탁한다.
이후로는 많이 어려움

---
### 세션, 토큰, jwt
'상태'를 일정범위(시간) 만큼 유지시키는 목적으로 쓰인다.  주로 로그인상태를 유지시키는 목적으로 쓰인다.
인증 : 계정 확인
인가(어서와이제이션) : 인증받은 사람의 권한에 대한 허가

세션 : 티켓을 반으로 잘라, 반쪽은 사용자의 브라우저, 반쪽은 서버에 저장(램, 하드, db 등)
  요청마다 이 표딱지를 실어보낸다. Session Id를 검사.
  서버의 메모리 부족. 서버가 꺼지거나 하면 서버에 저장된 반쪽 다 날라감.
  즉 서버 재시작하면 세션 다 끊김.
  대규모라서 여러대의 서버를 쓴다면 세션 유지 더 어렵지.

JWT : JSON Web Token
  역시 토큰을 발급하는데 찢어서 주지않고 그냥 준다.
  서버가 뭔가 기억하지 않는다는 얘기다.
  헤더, 페이로드, 서명 정보로    인코딩된 3가지의 데이터를 이어붙인 토큰을 발급한다.
  base64로 디코딩 할 수 있음. 조작을 막기위해 1,3번 정보가 있는거다.

  세션을 대체하기에는 큰 결점이 있다.
  세션이 구현만 되면 기억하는 대상의 상태들을 언제든 제어할수 있다는 의미다.
  pc, 폰 로그인 등 동시로그인을 한다는 등.
  내가 기억하지 않아서 편하긴 한데 통제를 못한다는 것.
  access token(기간 짧다), refresh token(기간 길다) 방법으로 대안.
토큰 : 쿠키처럼 파일로 관리


#### CDN
Content Delivery Network
[얄코강의](https://www.youtube.com/watch?v=_kcoeK0ITkQ)
전세계의 수많은 요청에 응답해야한다. 분산시키는 기술.
미러사이트가 아니고 컨텐츠 전달이라는 용도에 특화된 기술
'본사가 아니라 체인점 지점으로 가는 매커니즘'이다. CDN업체에는 상당수가 캐싱되어있다.
동적 캐싱(체인점에 없는것만 본사에 요청), 정적 캐싱(미리 받아놓음)
CDN을 쓰면 CDN업체에 나가는 비용이 있지만 본 서버를 돌리는 비용이 더 줄어들기 때문에 사용한다.
속도, 대역폭(차선. 동시에 얼마나)
오리지널 서버로 가는 길을 넓게 깔 필요가 없다. 서버 호스팅 비용 절감.
한곳이 터져도 다른곳에 접속.
가용성, 안정성, 디도스 방어등 보안성 향상.
